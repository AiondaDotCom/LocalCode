#!/usr/bin/env perl
use strict;
use warnings;
use lib 'lib';
use Getopt::Long;
use LocalCode::Config;
use LocalCode::Client;
use LocalCode::UI;
use LocalCode::Tools;
use LocalCode::Permissions;
use LocalCode::Session;

# Parse command line options
my %opts;
GetOptions(
    \%opts,
    'help|h',
    'version|v',
    'test-all',
    'test-connection',
    'list-models',
    'set-model=s',
    'current-model',
    'auto-yes',
    'auto-no',
    'simulate',
    'test-mode',
    'test-tui-stdin',
    'test-tui-script=s',
    'self-test',
    'config-test',
    'validate-tools',
    'health-check',
);

# Show help
if ($opts{help}) {
    print_help();
    exit 0;
}

# Show version
if ($opts{version}) {
    my $config = LocalCode::Config->new();
    print "LocalCode version " . $config->get_version() . "\n";
    exit 0;
}

# Initialize components
my $config = LocalCode::Config->new();
my $client = LocalCode::Client->new(config => $config);
my $permissions = LocalCode::Permissions->new(config => $config);
my $tools = LocalCode::Tools->new(config => $config, permissions => $permissions);
my $session = LocalCode::Session->new(config => $config);

# Connect to Ollama to detect available models
$client->connect();

# Load last used model
my $last_model = $config->load_last_model();
if ($last_model) {
    # Try to set the model - will only succeed if it's valid
    $client->set_model($last_model);
}

my $ui = LocalCode::UI->new(
    config => $config,
    client => $client,
    tools => $tools,
    permissions => $permissions,
    session => $session,
);

# Set testing modes based on options
if ($opts{'auto-yes'}) {
    $config->set_testing_mode('auto_yes');
    $permissions->set_testing_mode('auto_yes');
    $tools->{auto_approve} = 1;
    $ui->{auto_approve} = 1;
}

if ($opts{'auto-no'}) {
    $config->set_testing_mode('auto_no');
    $permissions->set_testing_mode('auto_no');
    $tools->{auto_approve} = 0;
    $ui->{auto_approve} = 0;
}

if ($opts{simulate}) {
    $config->set_testing_mode('simulate');
    $tools->{simulate_only} = 1;
}

if ($opts{'test-mode'}) {
    $config->set_testing_mode('mock');
    $client->{mock_mode} = 1;
    $client->{mock_models} = ['llama3', 'llama2', 'mistral'];
    $client->set_model('llama3');  # Set default model for test mode
    $tools->{mock_execution} = 1;
    $ui->{test_mode} = 1;
}

# Handle specific commands
if ($opts{'test-connection'}) {
    test_connection($client);
} elsif ($opts{'list-models'}) {
    list_models($client);
} elsif ($opts{'set-model'}) {
    set_model($client, $opts{'set-model'}, $config);
} elsif ($opts{'current-model'}) {
    current_model($client);
} elsif ($opts{'test-all'}) {
    run_all_tests();
} elsif ($opts{'self-test'}) {
    run_self_test($ui, $client, $tools, $permissions);
} elsif ($opts{'config-test'}) {
    test_config($config);
} elsif ($opts{'validate-tools'}) {
    validate_tools($tools);
} elsif ($opts{'health-check'}) {
    health_check($client, $config);
} elsif ($opts{'test-tui-stdin'}) {
    test_tui_stdin($ui);
} elsif ($opts{'test-tui-script'}) {
    test_tui_script($ui, $opts{'test-tui-script'});
} elsif (@ARGV) {
    # Direct prompt mode
    my $prompt = join(' ', @ARGV);
    direct_prompt($ui, $client, $prompt);
} else {
    # Interactive TUI mode
    interactive_mode($ui, $client, $session);
}

# Command implementations
sub print_help {
    print "LocalCode - Perl-based AI Coding Agent for Ollama\n\n";
    print "Usage: localcode [OPTIONS] [PROMPT]\n\n";
    print "Options:\n";
    print "  --help                Show this help\n";
    print "  --version             Show version information\n";
    print "  --list-models         List available Ollama models\n";
    print "  --set-model MODEL     Switch to specific model\n";
    print "  --current-model       Show current model\n";
    print "  --test-connection     Test Ollama connection\n";
    print "  --auto-yes            Auto-approve all permissions\n";
    print "  --auto-no             Auto-deny all permissions\n";
    print "  --simulate            Simulate tool execution\n";
    print "  --test-mode           Mock mode for testing\n";
    print "  --self-test           Run comprehensive self-tests\n";
    print "  --config-test         Test configuration\n";
    print "  --validate-tools      Validate tool definitions\n";
    print "  --health-check        System health check\n";
    print "  --test-tui-stdin      Test TUI with stdin input\n";
    print "  --test-tui-script FILE Test TUI with script file\n\n";
    print "Interactive Commands:\n";
    print "  /help                 Show TUI help\n";
    print "  /models               List models\n";
    print "  /model NAME           Switch model\n";
    print "  /exit                 Exit program\n\n";
    print "Examples:\n";
    print "  localcode                           # Interactive mode\n";
    print "  localcode \"write hello world\"       # Direct prompt\n";
    print "  localcode --auto-yes \"create script\" # Auto-approve mode\n";
    print "  localcode --simulate \"dangerous cmd\" # Simulation mode\n";
}

sub test_connection {
    my ($client) = @_;
    
    if ($client->connect()) {
        print "‚úì Connection to Ollama successful\n";
        print "Status: " . $client->get_status() . "\n";
        my @models = $client->list_models();
        print "Available models: " . scalar(@models) . "\n";
        exit 0;
    } else {
        print "‚úó Failed to connect to Ollama\n";
        print "Check if Ollama is running on localhost:11434\n";
        exit 1;
    }
}

sub list_models {
    my ($client) = @_;
    
    $client->connect() unless $client->{mock_mode};
    my @models = $client->list_models();
    my $current = $client->get_current_model();
    
    print "Available models:\n";
    for my $model (@models) {
        print "- $model";
        print " (current)" if $current && $model eq $current;
        print "\n";
    }
}

sub set_model {
    my ($client, $model, $config) = @_;
    
    # Trim whitespace from model name
    $model =~ s/^\s+|\s+$//g if $model;
    
    $client->connect() unless $client->{mock_mode};
    if ($client->set_model($model)) {
        print "‚úì Switched to model: $model\n";
        
        # Save as last used model
        $config->save_last_model($model) if $config;
    } else {
        print "‚úó Model '$model' not found or unavailable\n";
        exit 1;
    }
}

sub current_model {
    my ($client) = @_;
    
    # Connect first to initialize models
    $client->connect() unless $client->{mock_mode};
    
    my $current = $client->get_current_model();
    print "Current model: " . ($current || 'none') . "\n";
}

sub run_all_tests {
    print "Running all tests...\n";
    exec 'make', 'test';
}

sub run_self_test {
    my ($ui, $client, $tools, $permissions) = @_;
    
    print "Running self-tests...\n\n";
    
    # Test UI commands
    print "Testing TUI commands:\n";
    my $result = $ui->run_comprehensive_test_suite();
    print $result->{passed} ? "‚úì" : "‚úó";
    print " TUI commands: $result->{total_tests} tests\n";
    
    # Test client connection
    print "Testing client:\n";
    $client->{mock_mode} = 1;
    $client->{mock_models} = ['llama3', 'llama2'];
    print $client->connect() ? "‚úì" : "‚úó";
    print " Client connection\n";
    
    # Test tools
    print "Testing tools:\n";
    my @tool_list = $tools->list_tools();
    print "‚úì Tools loaded: " . scalar(@tool_list) . "\n";
    
    print "\nSelf-test completed.\n";
}

sub test_config {
    my ($config) = @_;
    
    print "Testing configuration...\n";
    my $defaults = $config->load_defaults();
    print $config->validate($defaults) ? "‚úì" : "‚úó";
    print " Configuration validation\n";
    
    print "Ollama host: " . $config->get('ollama.host') . "\n";
    print "Ollama port: " . $config->get('ollama.port') . "\n";
    print "Default model: " . $config->get('ollama.default_model') . "\n";
}

sub validate_tools {
    my ($tools) = @_;
    
    print "Validating tools...\n";
    my @tool_list = $tools->list_tools();
    
    for my $tool (@tool_list) {
        my $valid = $tools->validate_tool($tool);
        my $permission = $tools->check_permission($tool);
        my $safety = $permission == 0 ? 'SAFE' : $permission == 1 ? 'DANGEROUS' : 'BLOCKED';
        
        print $valid ? "‚úì" : "‚úó";
        print " $tool [$safety]\n";
    }
    
    print "\nTotal tools: " . scalar(@tool_list) . "\n";
}

sub health_check {
    my ($client, $config) = @_;
    
    print "System health check...\n\n";
    
    # Check config
    print "Configuration: ";
    my $defaults = $config->load_defaults();
    print $config->validate($defaults) ? "‚úì OK\n" : "‚úó FAIL\n";
    
    # Check Ollama connection
    print "Ollama connection: ";
    if ($client->connect()) {
        print "‚úì OK\n";
        print "Available models: " . scalar($client->list_models()) . "\n";
    } else {
        print "‚úó FAIL\n";
    }
    
    # Check dependencies
    print "Dependencies: ";
    eval { require JSON; require LWP::UserAgent; require YAML::Tiny; };
    print $@ ? "‚úó FAIL\n" : "‚úì OK\n";
    
    print "\nHealth check completed.\n";
}

sub test_tui_stdin {
    my ($ui) = @_;
    
    # Read commands from stdin
    my $input = do { local $/; <STDIN> };
    my @commands = $ui->parse_stdin_commands($input);
    
    my $result = $ui->run_automated_session(\@commands);
    print $result->{output};
}

sub test_tui_script {
    my ($ui, $script_file) = @_;
    
    my @commands = $ui->read_command_file($script_file);
    unless (@commands) {
        print "‚úó Failed to read script file: $script_file\n";
        exit 1;
    }
    
    print "Running TUI script: $script_file\n";
    my $result = $ui->run_automated_session(\@commands);
    print $result->{output};
}

sub direct_prompt {
    my ($ui, $client, $prompt) = @_;
    
    # Connect to Ollama unless in mock mode
    unless ($client->{mock_mode}) {
        unless ($client->connect()) {
            print "‚úó Failed to connect to Ollama\n";
            exit 1;
        }
    }
    
    # Create a temporary session for direct prompts
    my $session = LocalCode::Session->new();
    $session->new_session('direct_prompt');
    $session->add_message('user', $prompt);
    
    # Get system prompt and create messages array
    my $system_prompt = $ui->get_system_prompt();
    my $messages = $session->get_messages_for_chat($system_prompt);
    
    # Send to Ollama with full context
    my $response = $client->chat("", undef, $messages);
    
    # Parse tool calls and execute them
    my @tool_calls = $ui->parse_tool_calls($response);
    
    if (@tool_calls) {
        print "Tool calls detected:\n";
        for my $tool_call (@tool_calls) {
            print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
        }
    }
    
    print "\nResponse: $response\n";
}

sub interactive_mode {
    my ($ui, $client, $session) = @_;

    my $version = $config->get_version();

    # ASCII Art Banner with colors
    my $cyan = "\e[36m";
    my $blue = "\e[34m";
    my $bold = "\e[1m";
    my $dim = "\e[2m";
    my $reset = "\e[0m";

    print "\n";
    print "${cyan}${bold}\n";
    print "    ‚ï¶  ‚îå‚îÄ‚îê‚îå‚îÄ‚îê‚îå‚îÄ‚îê‚î¨  ‚ïî‚ïê‚ïó‚îå‚îÄ‚îê‚îå‚î¨‚îê‚îå‚îÄ‚îê\n";
    print "    ‚ïë  ‚îÇ ‚îÇ‚îÇ  ‚îú‚îÄ‚î§‚îÇ  ‚ïë  ‚îÇ ‚îÇ ‚îÇ‚îÇ‚îú‚î§ \n";
    print "    ‚ï©‚ïê‚ïù‚îî‚îÄ‚îò‚îî‚îÄ‚îò‚î¥ ‚î¥‚î¥‚îÄ‚ïù‚ïö‚ïê‚ïù‚îî‚îÄ‚îò‚îÄ‚î¥‚îò‚îî‚îÄ‚îò\n";
    print "${reset}${blue}    ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${reset}\n";
    print "${dim}    AI Coding Agent ‚Ä¢ ${reset}${bold}v$version${reset}\n";
    print "${dim}    by Aionda GmbH${reset}\n";
    print "\n";
    print "Type ${bold}/help${reset} for commands or ${bold}/exit${reset} to quit\n";
    
    # Setup readline for autocompletion (REQUIRED - will die if not available)
    $ui->setup_readline();
    
    # Connect to Ollama unless in mock mode
    unless ($client->{mock_mode}) {
        unless ($client->connect()) {
            print "‚úó Failed to connect to Ollama\n";
            print "Starting in offline mode...\n\n";
        }
    }
    
    # Ensure a model is selected - but only if no last model was loaded
    my $current_model = $client->get_current_model();
    if (!$current_model && !$client->{mock_mode} && !$last_model) {
        # Try to initialize a model if none is set and no last model was available
        if ($client->initialize_current_model()) {
            $current_model = $client->get_current_model();
        }
    } elsif ($last_model) {
        # Use the loaded last model even if get_current_model() returns undef
        $current_model = $last_model;
    }
    
    # Show current model
    if ($current_model) {
        print "Model: $current_model\n\n";
    } else {
        print "Model: none selected\n\n";
    }
    
    # Create new session
    $session->new_session('interactive_session');

    # Get model info for context window size
    if ($current_model) {
        $client->get_model_info($current_model);
    }

    # Track "always allow" permissions for this session
    my %always_allow_tools = ();

    while (1) {
        my $input = $ui->readline_prompt("", $client);
        chomp $input if defined $input;
        
        # Handle EOF (Ctrl+D) - save history and exit gracefully
        unless (defined $input) {
            print "\n"; # Add newline after Ctrl+D
            $ui->save_readline_history();
            last;
        }
        
        next if $input eq '';
        
        # Handle slash commands
        if ($input =~ /^\//) {
            my $result = $ui->handle_slash_command($input, $client, $session);
            
            if ($result) {
                # Exit on /exit command without printing message again
                if ($input eq '/exit') {
                    print "$result\n";
                    last;
                } else {
                    print "$result\n";
                }
            } else {
                print "Unknown command. Type /help for available commands.\n";
            }
            next;
        }
        
        # Regular chat with full conversation history
        my $system_prompt = $ui->get_system_prompt();

        # Add current user message to session before sending
        $session->add_message('user', $input);

        # Proactive context management: compress history if over 90%
        my $stats = $client->get_context_stats();
        if ($stats && $stats->{percentage} >= 90) {
            print "‚ö†Ô∏è  Context usage at $stats->{percentage}%, compressing history...\n";
            my $stop_compress = $ui->show_loading("üì¶ Summarizing conversation");
            my $compressed = $session->compress_history($client); # Dynamic calculation
            $stop_compress->();

            if ($compressed > 0) {
                print "   ‚úì Compressed $compressed messages into summary\n";
            } else {
                # Fallback to truncation if compression fails
                print "   ‚ö†Ô∏è  Compression failed, falling back to truncation...\n";
                my $removed = $session->truncate_history_for_context(3);
                print "   Removed $removed old messages\n";
            }
        }

        # Try to send chat with full conversation history
        my $response;
        my $retry_count = 0;
        my $max_retries = 3;

        while ($retry_count <= $max_retries) {
            # Get full conversation as messages array
            my $messages = $session->get_messages_for_chat($system_prompt);
            
            # Send to Ollama with full context
            my $stop_loading = $ui->show_loading("ü§ñ Thinking");
            $response = $client->chat("", undef, $messages);
            $stop_loading->();
            
            # Show response
            print "ü§ñ $response\n\n";
            
            # Check if we got a context length error
            if (ref $response eq 'HASH' && $response->{error} && $response->{error} eq 'context_length_exceeded') {
                $retry_count++;
                if ($retry_count <= $max_retries) {
                    print "‚ö†Ô∏è  Context length exceeded, truncating history and retrying ($retry_count/$max_retries)...\n";
                    my $removed = $session->truncate_history_for_context(3); # Remove oldest 3 pairs
                    print "   Removed $removed old messages\n";
                } else {
                    print "‚ùå Context still too long after $max_retries retries. Raw error: $response->{raw_error}\n";
                    $response = "Error: Context length exceeded and could not be resolved by truncating history.";
                    last;
                }
            } else {
                # Success or other error - break out of retry loop
                last;
            }
        }
        
        # Add assistant response to session (only if it's not an error hash)
        if (!ref $response) {
            $session->add_message('assistant', $response);
        }
        
        # Parse and execute tool calls (only if response is a string, not an error hash)
        my @tool_calls = ();
        my $tool_results = [];
        
        if (!ref $response) {
            @tool_calls = $ui->parse_tool_calls($response);
            
            # Debug: Show if response contains tool-related content
            if (!@tool_calls && $response =~ /<tool_call|bash|write|read/i) {
                print "üîç Debug: Response contains tool-related content but no tool calls parsed\n";
                print "   Response preview: " . substr($response, 0, 500) . "...\n";
                print "   Found " . scalar(@tool_calls) . " tool calls\n\n";
            } elsif ($ENV{DEBUG_LOCALCODE}) {
                print "üîç Debug: Found " . scalar(@tool_calls) . " tool calls in response\n";
                for my $call (@tool_calls) {
                    print "   - $call->{name}(" . join(', ', @{$call->{args}}) . ")\n";
                }
                print "\n";
            }
        }
        
        if (@tool_calls) {
            print "\nExecuting tool calls:\n";
            
            # Show how many tool calls we're executing
            if (scalar @tool_calls > 1) {
                print "üîß Executing " . scalar(@tool_calls) . " tool calls in sequence...\n\n";
            }
            
            for my $tool_call (@tool_calls) {
                # Show XML format for clarity
                if ($tool_call->{raw_args}) {
                    my $args_str = join(', ', map { "\"$_\": \"$tool_call->{raw_args}->{$_}\"" } keys %{$tool_call->{raw_args}});
                    print "- <tool_call name=\"$tool_call->{name}\" args={$args_str}>\n";
                } else {
                    print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
                }
                
                # Check permissions and execute
                my $permission = $permissions->get_permission_for_tool($tool_call->{name});
                my $tool_result = {
                    tool => $tool_call->{name},
                    args => $tool_call->{args},
                    success => 0,
                    message => "",
                };
                
                if ($permission == 0) {  # SAFE
                    my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                    if ($result->{success}) {
                        print "  ‚úÖ " . ($result->{message} || "Success") . "\n";
                        $tool_result->{success} = 1;
                        $tool_result->{message} = $result->{message} || "Success";
                        
                        # Show output for exec/bash commands and content for read/webfetch/browser tools
                        if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                            my $output = $result->{output};
                            chomp $output;  # Remove trailing newline
                            print "  Output: $output\n";
                            $tool_result->{output} = $output;
                        } elsif (($tool_call->{name} eq 'read' || $tool_call->{name} eq 'webfetch' || $tool_call->{name} eq 'websearch' || $tool_call->{name} eq 'webopen' || $tool_call->{name} eq 'webfind' || $tool_call->{name} eq 'webget') && $result->{content}) {
                            my $content = $result->{content};
                            # Show content length and truncated preview
                            my $content_length = length($content);
                            my $display_content = $content_length > 500 ? substr($content, 0, 500) . "..." : $content;
                            print "  Content ($content_length bytes): $display_content\n";
                            $tool_result->{content} = $content;  # Full content for AI
                        }
                    } else {
                        print "  ‚ùå " . ($result->{error} || $result->{message} || "Failed") . "\n";
                        $tool_result->{success} = 0;
                        $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                        
                        # Show detailed error information
                        if ($result->{output}) {
                            my $output = $result->{output};
                            chomp $output;
                            print "     Error Details: $output\n";
                            $tool_result->{output} = $output;
                        }
                        if ($result->{error} && $result->{error} ne ($result->{message} || "")) {
                            print "     Error Message: $result->{error}\n";
                        }
                        if ($result->{exit_code}) {
                            print "     Exit Code: $result->{exit_code}\n";
                        }
                    }
                } elsif ($permission == 1) {  # DANGEROUS - ask for permission
                    my $auto_approve = $ui->{auto_approve} || 0;
                    my $answer = '';

                    # Check if this tool is in "always allow" list
                    if ($always_allow_tools{$tool_call->{name}}) {
                        print "  ‚ö†Ô∏è  This is a dangerous operation (always allowed for this session)!\n";
                        print "  Tool: $tool_call->{name}\n";
                        print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                        $answer = 'y';
                    } elsif ($auto_approve) {
                        print "  ‚ö†Ô∏è  This is a dangerous operation (auto-approved)!\n";
                        print "  Tool: $tool_call->{name}\n";
                        print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                        $answer = 'y';
                    } else {
                        print "  ‚ö†Ô∏è  This is a dangerous operation!\n";
                        print "  Tool: $tool_call->{name}\n";
                        print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                        print "  Allow? (y/N/a): ";

                        $answer = <STDIN>;
                        chomp $answer if defined $answer;

                        # Handle "always allow" option
                        if ($answer && $answer =~ /^a(lways)?$/i) {
                            $always_allow_tools{$tool_call->{name}} = 1;
                            print "  ‚úì Tool '$tool_call->{name}' will be always allowed for this session\n";
                            $answer = 'y';  # Treat as 'yes' for this execution
                        }
                    }

                    if ($answer && $answer =~ /^y(es)?$/i) {
                        my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                        if ($result->{success}) {
                            print "  ‚úÖ " . ($result->{message} || "Success") . "\n";
                            $tool_result->{success} = 1;
                            $tool_result->{message} = $result->{message} || "Success";
                            
                            # Show output for exec/bash commands and content for read/webfetch/browser tools
                            if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                my $output = $result->{output};
                                chomp $output;  # Remove trailing newline
                                print "  Output: $output\n";
                                $tool_result->{output} = $output;
                            } elsif (($tool_call->{name} eq 'read' || $tool_call->{name} eq 'webfetch' || $tool_call->{name} eq 'websearch' || $tool_call->{name} eq 'webopen' || $tool_call->{name} eq 'webfind' || $tool_call->{name} eq 'webget') && $result->{content}) {
                                my $content = $result->{content};
                                # Show content length and truncated preview
                                my $content_length = length($content);
                                my $display_content = $content_length > 500 ? substr($content, 0, 500) . "..." : $content;
                                print "  Content ($content_length bytes): $display_content\n";
                                $tool_result->{content} = $content;  # Full content for AI
                            }
                        } else {
                            print "  ‚ùå " . ($result->{error} || $result->{message} || "Failed") . "\n";
                            $tool_result->{success} = 0;
                            $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                            
                            # Show detailed error information
                            if ($result->{output}) {
                                my $output = $result->{output};
                                chomp $output;
                                print "     Error Details: $output\n";
                                $tool_result->{output} = $output;
                            }
                            if ($result->{error} && $result->{error} ne ($result->{message} || "")) {
                                print "     Error Message: $result->{error}\n";
                            }
                            if ($result->{exit_code}) {
                                print "     Exit Code: $result->{exit_code}\n";
                            }
                        }
                    } else {
                        print "  ‚ùå Operation cancelled\n";
                        $tool_result->{success} = 0;
                        $tool_result->{message} = "Operation cancelled by user";
                    }
                } else {  # BLOCKED
                    print "  üö´ Operation blocked by policy\n";
                    $tool_result->{success} = 0;
                    $tool_result->{message} = "Operation blocked by policy";
                }
                
                push @$tool_results, $tool_result;
            }
            print "\n";
            
            # Send tool results back to LLM for follow-up
            my $tool_feedback = $ui->format_tool_results($tool_results);
            
            # Debug: Show what we're sending to AI
            if ($ENV{DEBUG_LOCALCODE}) {
                print "üîç Debug: Sending to AI:\n$tool_feedback\n\n";
            }
            
            # Add tool results to session first - use 'user' instead of 'system' for better compatibility
            $session->add_message('user', "Tool results:\n" . $tool_feedback);

            # Proactive context management before processing tool results
            my $tool_stats = $client->get_context_stats();
            if ($tool_stats && $tool_stats->{percentage} >= 90) {
                print "‚ö†Ô∏è  Context usage at $tool_stats->{percentage}%, compressing history...\n";
                my $stop_compress_tool = $ui->show_loading("üì¶ Summarizing conversation");
                my $compressed_tool = $session->compress_history($client); # Dynamic calculation
                $stop_compress_tool->();

                if ($compressed_tool > 0) {
                    print "   ‚úì Compressed $compressed_tool messages into summary\n";
                } else {
                    print "   ‚ö†Ô∏è  Compression failed, falling back to truncation...\n";
                    my $removed_tool = $session->truncate_history_for_context(3);
                    print "   Removed $removed_tool old messages\n";
                }
            }

            # Display current context status
            $tool_stats = $client->get_context_stats();
            if ($tool_stats && $tool_stats->{context_window} > 0) {
                my $percentage = $tool_stats->{percentage};
                my $total = $tool_stats->{total_tokens};
                my $window = $tool_stats->{context_window};

                # Color coding
                my $color_code;
                if ($percentage >= 90) {
                    $color_code = "31";  # Red
                } elsif ($percentage >= 70) {
                    $color_code = "33";  # Yellow
                } else {
                    $color_code = "32";  # Green
                }

                my $term_width = $ui->get_term_width();
                my $context_text = sprintf("\e[%sm%d%% \e[0m(%d/%d)", $color_code, $percentage, $total, $window);
                my $context_visible = $context_text;
                $context_visible =~ s/\e\[[0-9;]*m//g;

                my $right_part = "[ Context: " . $context_visible . " ]";
                my $right_len = length($right_part);
                my $left_bars = $term_width - $right_len;
                $left_bars = 3 if $left_bars < 3;

                my $bar = "\e[2m" . ("‚îÄ" x $left_bars) . "\e[0m[ Context: " . $context_text . " ]";
                print $bar . "\n";
            }

            # Get full conversation including tool feedback for follow-up
            my $follow_up_messages = $session->get_messages_for_chat($system_prompt);

            my $stop_loading2 = $ui->show_loading("ü§ñ Processing tool results");
            my $follow_up_response = $client->chat("", undef, $follow_up_messages);
            $stop_loading2->();

            # Add follow-up response to session and display
            if (!ref $follow_up_response && $follow_up_response && $follow_up_response !~ /^Error:/) {
                $session->add_message('assistant', $follow_up_response);
                print "Follow-up: $follow_up_response\n\n";
                
                # IMPORTANT: Also parse follow-up response for tool calls!
                my @follow_up_tool_calls = $ui->parse_tool_calls($follow_up_response);
                
                if (@follow_up_tool_calls) {
                    print "Follow-up contains " . scalar(@follow_up_tool_calls) . " additional tool calls:\n";
                    
                    my @follow_up_results = ();
                    my $should_stop = 0;
                    
                    for my $tool_call (@follow_up_tool_calls) {
                        print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
                        
                        # Execute the follow-up tool call
                        my $permission = $permissions->get_permission_for_tool($tool_call->{name});
                        my $tool_result = {
                            tool => $tool_call->{name},
                            args => $tool_call->{args},
                            success => 0,
                            message => "",
                        };
                        
                        if ($permission == 0) {  # SAFE
                            my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                            if ($result->{success}) {
                                print "  ‚úÖ " . ($result->{message} || "Success") . "\n";
                                $tool_result->{success} = 1;
                                $tool_result->{message} = $result->{message} || "Success";
                                
                                # Show output for relevant tools
                                if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                    my $output = $result->{output};
                                    chomp $output;
                                    print "  Output: $output\n";
                                    $tool_result->{output} = $output;
                                }
                            } else {
                                print "  ‚ùå " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                $tool_result->{success} = 0;
                                $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                                
                                # Show detailed error information
                                if ($result->{output}) {
                                    my $output = $result->{output};
                                    chomp $output;
                                    print "     Error Details: $output\n";
                                    $tool_result->{output} = $output;
                                }
                                $should_stop = 1;  # Stop on first failure
                            }
                        } elsif ($permission == 1) {  # DANGEROUS - ask for permission
                            my $auto_approve = $ui->{auto_approve} || 0;
                            my $answer = '';

                            # Check if this tool is in "always allow" list
                            if ($always_allow_tools{$tool_call->{name}}) {
                                print "  ‚ö†Ô∏è  This is a dangerous operation (always allowed for this session)!\n";
                                print "  Tool: $tool_call->{name}\n";
                                print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                $answer = 'y';
                            } elsif ($auto_approve) {
                                print "  ‚ö†Ô∏è  This is a dangerous operation (auto-approved)!\n";
                                print "  Tool: $tool_call->{name}\n";
                                print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                $answer = 'y';
                            } else {
                                print "  ‚ö†Ô∏è  This is a dangerous operation!\n";
                                print "  Tool: $tool_call->{name}\n";
                                print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                print "  Allow? (y/N/a): ";

                                $answer = <STDIN>;
                                chomp $answer if defined $answer;

                                # Handle "always allow" option
                                if ($answer && $answer =~ /^a(lways)?$/i) {
                                    $always_allow_tools{$tool_call->{name}} = 1;
                                    print "  ‚úì Tool '$tool_call->{name}' will be always allowed for this session\n";
                                    $answer = 'y';  # Treat as 'yes' for this execution
                                }
                            }

                            if ($answer && $answer =~ /^y(es)?$/i) {
                                my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                                if ($result->{success}) {
                                    print "  ‚úÖ " . ($result->{message} || "Success") . "\n";
                                    $tool_result->{success} = 1;
                                    $tool_result->{message} = $result->{message} || "Success";
                                    
                                    # Show output for bash/exec tools
                                    if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                        my $output = $result->{output};
                                        chomp $output;
                                        print "  Output: $output\n";
                                        $tool_result->{output} = $output;
                                    }
                                } else {
                                    print "  ‚ùå " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                    $tool_result->{success} = 0;
                                    $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                                    
                                    # Show detailed error information
                                    if ($result->{output}) {
                                        my $output = $result->{output};
                                        chomp $output;
                                        print "     Error Details: $output\n";
                                        $tool_result->{output} = $output;
                                    }
                                    $should_stop = 1;  # Stop on first failure
                                }
                            } else {
                                print "  ‚ùå Operation cancelled\n";
                                $tool_result->{success} = 0;
                                $tool_result->{message} = "Operation cancelled by user";
                                $should_stop = 1;  # Stop on cancellation
                            }
                        } else {  # BLOCKED
                            print "  üö´ Operation blocked by policy\n";
                            $tool_result->{success} = 0;
                            $tool_result->{message} = "Operation blocked by policy";
                            $should_stop = 1;  # Stop on blocked
                        }
                        
                        push @follow_up_results, $tool_result;
                        
                        # Stop execution on first failure/cancellation/block
                        last if $should_stop;
                    }
                    print "\n";
                    
                    # Send follow-up results back to AI (like regular tool execution)
                    if (@follow_up_results) {
                        my $follow_up_feedback = $ui->format_tool_results(\@follow_up_results);
                        
                        # Debug: Show what we're sending to AI for follow-up results
                        if ($ENV{DEBUG_LOCALCODE}) {
                            print "üîç Debug: Sending follow-up results to AI:\n$follow_up_feedback\n\n";
                        }
                        
                        # Add follow-up tool results to session
                        $session->add_message('user', "Follow-up tool results:\n" . $follow_up_feedback);

                        # Proactive context management before follow-up processing
                        my $followup_stats = $client->get_context_stats();
                        if ($followup_stats && $followup_stats->{percentage} >= 90) {
                            print "‚ö†Ô∏è  Context usage at $followup_stats->{percentage}%, compressing history...\n";
                            my $stop_compress_followup = $ui->show_loading("üì¶ Summarizing conversation");
                            my $compressed_followup = $session->compress_history($client); # Dynamic calculation
                            $stop_compress_followup->();

                            if ($compressed_followup > 0) {
                                print "   ‚úì Compressed $compressed_followup messages into summary\n";
                            } else {
                                print "   ‚ö†Ô∏è  Compression failed, falling back to truncation...\n";
                                my $removed_followup = $session->truncate_history_for_context(3);
                                print "   Removed $removed_followup old messages\n";
                            }
                        }

                        # Display current context status
                        $followup_stats = $client->get_context_stats();
                        if ($followup_stats && $followup_stats->{context_window} > 0) {
                            my $percentage = $followup_stats->{percentage};
                            my $total = $followup_stats->{total_tokens};
                            my $window = $followup_stats->{context_window};

                            # Color coding
                            my $color_code;
                            if ($percentage >= 90) {
                                $color_code = "31";  # Red
                            } elsif ($percentage >= 70) {
                                $color_code = "33";  # Yellow
                            } else {
                                $color_code = "32";  # Green
                            }

                            my $term_width = $ui->get_term_width();
                            my $context_text = sprintf("\e[%sm%d%% \e[0m(%d/%d)", $color_code, $percentage, $total, $window);
                            my $context_visible = $context_text;
                            $context_visible =~ s/\e\[[0-9;]*m//g;

                            my $right_part = "[ Context: " . $context_visible . " ]";
                            my $right_len = length($right_part);
                            my $left_bars = $term_width - $right_len;
                            $left_bars = 3 if $left_bars < 3;

                            my $bar = "\e[2m" . ("‚îÄ" x $left_bars) . "\e[0m[ Context: " . $context_text . " ]";
                            print $bar . "\n";
                        }

                        # Get AI response to follow-up results
                        my $final_messages = $session->get_messages_for_chat($system_prompt);

                        my $stop_loading3 = $ui->show_loading("ü§ñ Processing follow-up results");
                        my $final_response = $client->chat("", undef, $final_messages);
                        $stop_loading3->();

                        # Display final AI response
                        if (!ref $final_response && $final_response && $final_response !~ /^Error:/) {
                            $session->add_message('assistant', $final_response);
                            print "Final: $final_response\n\n";
                            
                            # IMPORTANT: Also parse final response for tool calls!
                            my @final_tool_calls = $ui->parse_tool_calls($final_response);
                            
                            if (@final_tool_calls) {
                                print "Final response contains " . scalar(@final_tool_calls) . " additional tool calls:\n";
                                
                                for my $tool_call (@final_tool_calls) {
                                    print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
                                    
                                    # Execute the final tool call
                                    my $permission = $permissions->get_permission_for_tool($tool_call->{name});
                                    my $tool_result = {
                                        tool => $tool_call->{name},
                                        args => $tool_call->{args},
                                        success => 0,
                                        message => "",
                                    };
                                    
                                    if ($permission == 0) {  # SAFE
                                        my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                                        if ($result->{success}) {
                                            print "  ‚úÖ " . ($result->{message} || "Success") . "\n";
                                            
                                            # Show output for relevant tools
                                            if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                                my $output = $result->{output};
                                                chomp $output;
                                                print "  Output: $output\n";
                                            } elsif (($tool_call->{name} eq 'read' || $tool_call->{name} eq 'webfetch' || $tool_call->{name} eq 'websearch' || $tool_call->{name} eq 'webopen' || $tool_call->{name} eq 'webfind' || $tool_call->{name} eq 'webget') && $result->{content}) {
                                                my $content = $result->{content};
                                                # Show content length and truncated preview
                                                my $content_length = length($content);
                                                my $display_content = $content_length > 500 ? substr($content, 0, 500) . "..." : $content;
                                                print "  Content ($content_length bytes): $display_content\n";
                                            }
                                        } else {
                                            print "  ‚ùå " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                        }
                                    } elsif ($permission == 1) {  # DANGEROUS - ask for permission
                                        my $auto_approve = $ui->{auto_approve} || 0;
                                        my $answer = '';

                                        # Check if this tool is in "always allow" list
                                        if ($always_allow_tools{$tool_call->{name}}) {
                                            print "  ‚ö†Ô∏è  This is a dangerous operation (always allowed for this session)!\n";
                                            print "  Tool: $tool_call->{name}\n";
                                            print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                            $answer = 'y';
                                        } elsif ($auto_approve) {
                                            print "  ‚ö†Ô∏è  This is a dangerous operation (auto-approved)!\n";
                                            $answer = 'y';
                                        } else {
                                            print "  ‚ö†Ô∏è  This is a dangerous operation!\n";
                                            print "  Tool: $tool_call->{name}\n";
                                            print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                            print "  Allow? (y/N/a): ";

                                            $answer = <STDIN>;
                                            chomp $answer if defined $answer;

                                            # Handle "always allow" option
                                            if ($answer && $answer =~ /^a(lways)?$/i) {
                                                $always_allow_tools{$tool_call->{name}} = 1;
                                                print "  ‚úì Tool '$tool_call->{name}' will be always allowed for this session\n";
                                                $answer = 'y';  # Treat as 'yes' for this execution
                                            }
                                        }

                                        if ($answer && $answer =~ /^y(es)?$/i) {
                                            my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                                            if ($result->{success}) {
                                                print "  ‚úÖ " . ($result->{message} || "Success") . "\n";
                                                
                                                # Show output for bash/exec tools
                                                if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                                    my $output = $result->{output};
                                                    chomp $output;
                                                    print "  Output: $output\n";
                                                }
                                            } else {
                                                print "  ‚ùå " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                            }
                                        } else {
                                            print "  ‚ùå Operation cancelled\n";
                                        }
                                    } else {  # BLOCKED
                                        print "  üö´ Operation blocked by policy\n";
                                    }
                                }
                                print "\n";
                            }
                        } elsif ($final_response =~ /^Error:/) {
                            print "‚ö†Ô∏è  Final response failed: $final_response\n\n";
                        }
                    }
                }
            } elsif ($follow_up_response =~ /^Error:/) {
                print "‚ö†Ô∏è  Follow-up failed: $follow_up_response\n";
                print "   Tool execution was successful, but AI follow-up had issues.\n\n";
            } elsif (!$follow_up_response || $follow_up_response eq '') {
                print "‚ÑπÔ∏è  No follow-up response from AI (empty response)\n\n";
            } else {
                print "‚ÑπÔ∏è  Unexpected follow-up response format: " . (ref $follow_up_response || 'string') . "\n\n";
            }
        } else {
            # No tool calls, response already shown above
            # Nothing additional to print
        }
    }
    
    # Only print goodbye if we didn't exit via /exit command
    # (which already printed its own goodbye)
}