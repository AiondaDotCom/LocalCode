#!/usr/bin/env perl
use strict;
use warnings;

# BEGIN INLINED MODULE: LocalCode::YAML
package LocalCode::YAML;
# Minimal YAML parser - only supports what we need for config files
# No external dependencies

sub new {
    my ($class) = @_;
    return bless {}, $class;
}

sub read {
    my ($class, $file) = @_;

    return unless -f $file;

    open my $fh, '<', $file or return;
    my $content = do { local $/; <$fh> };
    close $fh;

    return $class->parse($content);
}

sub parse {
    my ($class, $yaml_text) = @_;

    my $data = {};
    my @stack = ($data);
    my @indent_stack = (-1);
    my $current = $data;

    for my $line (split /\n/, $yaml_text) {
        # Skip comments and empty lines
        next if $line =~ /^\s*#/ || $line =~ /^\s*$/;

        # Calculate indentation
        my ($indent) = $line =~ /^(\s*)/;
        my $indent_level = length($indent);

        # Remove leading whitespace
        $line =~ s/^\s+//;

        # Handle key-value pairs
        if ($line =~ /^([^:]+):\s*(.*)$/) {
            my ($key, $value) = ($1, $2);
            $key =~ s/^\s+|\s+$//g;

            # Pop stack if dedented
            while (@indent_stack > 1 && $indent_level <= $indent_stack[-1]) {
                pop @stack;
                pop @indent_stack;
            }
            $current = $stack[-1];

            if ($value eq '' || $value eq '~') {
                # Empty value or null - check if next line is indented (nested object)
                $current->{$key} = {};
                push @stack, $current->{$key};
                push @indent_stack, $indent_level;
            } elsif ($value =~ /^['"](.*)['"]$/) {
                # Quoted string
                $current->{$key} = $1;
            } elsif ($value eq 'true') {
                $current->{$key} = 1;
            } elsif ($value eq 'false') {
                $current->{$key} = 0;
            } elsif ($value =~ /^-?\d+$/) {
                # Integer
                $current->{$key} = int($value);
            } elsif ($value =~ /^-?\d+\.\d+$/) {
                # Float
                $current->{$key} = $value + 0;
            } elsif ($value =~ /^\[(.+)\]$/) {
                # Inline array
                my $array_content = $1;
                $current->{$key} = [map {
                    s/^\s+|\s+$//g;
                    s/^['"]|['"]$//g;
                    $_
                } split /,/, $array_content];
            } else {
                # Plain string
                $current->{$key} = $value;
            }
        }
        # Handle array items
        elsif ($line =~ /^-\s+(.+)$/) {
            my $value = $1;
            $value =~ s/^['"]|['"]$//g;

            # Find the parent key (last key in current hash that has undefined or is becoming array)
            my @keys = keys %$current;
            if (@keys) {
                my $last_key = $keys[-1];
                if (!defined $current->{$last_key} || ref $current->{$last_key} eq 'HASH') {
                    $current->{$last_key} = [];
                }
                if (ref $current->{$last_key} eq 'ARRAY') {
                    push @{$current->{$last_key}}, $value;
                }
            }
        }
    }

    return [$data];
}

1;

# END INLINED MODULE: LocalCode::YAML

# BEGIN INLINED MODULE: LocalCode::JSON
package LocalCode::JSON;
# Minimal JSON encoder/decoder - no external dependencies
# Supports: objects, arrays, strings, numbers, booleans, null

# Boolean objects for true/false
our $true = bless \(my $dummy = 1), 'LocalCode::JSON::Boolean';
our $false = bless \(my $dummy2 = 0), 'LocalCode::JSON::Boolean';

sub new {
    my ($class) = @_;
    return bless { pretty => 0 }, $class;
}

sub pretty {
    my ($self) = @_;
    $self->{pretty} = 1;
    return $self;
}

sub encode {
    my ($self, $data) = @_;
    return $self->_encode($data, 0);
}

sub _encode {
    my ($self, $data, $depth) = @_;

    return 'null' unless defined $data;

    my $ref = ref $data;

    # Handle boolean objects
    if ($ref eq 'LocalCode::JSON::Boolean') {
        return $$data ? 'true' : 'false';
    }

    if (!$ref) {
        # Scalar
        if ($data =~ /^-?\d+$/ || $data =~ /^-?\d+\.\d+$/) {
            # Number (but not 0 or 1 alone, which could be booleans)
            return $data;
        } else {
            # String - escape special characters
            $data =~ s/\\/\\\\/g;
            $data =~ s/"/\\"/g;
            $data =~ s/\n/\\n/g;
            $data =~ s/\r/\\r/g;
            $data =~ s/\t/\\t/g;
            return qq{"$data"};
        }
    }
    elsif ($ref eq 'ARRAY') {
        return '[]' unless @$data;

        my $indent = $self->{pretty} ? '  ' x ($depth + 1) : '';
        my $newline = $self->{pretty} ? "\n" : '';
        my $space = $self->{pretty} ? ' ' : '';

        my @items = map { $self->_encode($_, $depth + 1) } @$data;
        if ($self->{pretty}) {
            return "[\n$indent" . join(",\n$indent", @items) . "\n" . ('  ' x $depth) . "]";
        } else {
            return '[' . join(',', @items) . ']';
        }
    }
    elsif ($ref eq 'HASH') {
        return '{}' unless %$data;

        my $indent = $self->{pretty} ? '  ' x ($depth + 1) : '';
        my $newline = $self->{pretty} ? "\n" : '';
        my $space = $self->{pretty} ? ' ' : '';

        my @pairs;
        for my $key (sort keys %$data) {
            my $encoded_key = qq{"$key"};
            my $encoded_value = $self->_encode($data->{$key}, $depth + 1);
            push @pairs, "$encoded_key:$space$encoded_value";
        }

        if ($self->{pretty}) {
            return "{\n$indent" . join(",\n$indent", @pairs) . "\n" . ('  ' x $depth) . "}";
        } else {
            return '{' . join(',', @pairs) . '}';
        }
    }
    elsif ($ref eq 'SCALAR') {
        # Boolean references
        return $$data ? 'true' : 'false';
    }
    else {
        die "Cannot encode reference type: $ref";
    }
}

sub decode {
    my ($self, $json) = @_;

    # Remove whitespace
    $json =~ s/^\s+//;
    $json =~ s/\s+$//;

    return $self->_decode($json);
}

sub _decode {
    my ($self, $json) = @_;

    # null
    return undef if $json eq 'null';

    # true/false
    return 1 if $json eq 'true';
    return 0 if $json eq 'false';

    # Numbers
    return $json + 0 if $json =~ /^-?\d+$/;
    return $json + 0.0 if $json =~ /^-?\d+\.\d+$/;

    # Strings
    if ($json =~ /^"(.*)"$/s) {
        my $str = $1;
        # Unescape Unicode sequences first (\uXXXX)
        $str =~ s/\\u([0-9a-fA-F]{4})/chr(hex($1))/eg;
        # Unescape other escape sequences
        $str =~ s/\\n/\n/g;
        $str =~ s/\\r/\r/g;
        $str =~ s/\\t/\t/g;
        $str =~ s/\\"/"/g;
        $str =~ s/\\\\/\\/g;
        return $str;
    }

    # Arrays
    if ($json =~ /^\[(.*)\]$/s) {
        my $content = $1;
        return [] if $content =~ /^\s*$/;

        my @items;
        my $depth = 0;
        my $in_string = 0;
        my $current = '';

        for my $char (split //, $content) {
            if ($char eq '"' && ($current eq '' || substr($current, -1) ne '\\')) {
                $in_string = !$in_string;
                $current .= $char;
            }
            elsif (!$in_string && ($char eq '[' || $char eq '{')) {
                $depth++;
                $current .= $char;
            }
            elsif (!$in_string && ($char eq ']' || $char eq '}')) {
                $depth--;
                $current .= $char;
            }
            elsif (!$in_string && $char eq ',' && $depth == 0) {
                $current =~ s/^\s+|\s+$//g;
                push @items, $self->_decode($current) if $current ne '';
                $current = '';
            }
            else {
                $current .= $char;
            }
        }

        if ($current ne '') {
            $current =~ s/^\s+|\s+$//g;
            push @items, $self->_decode($current);
        }

        return \@items;
    }

    # Objects
    if ($json =~ /^\{(.*)\}$/s) {
        my $content = $1;
        return {} if $content =~ /^\s*$/;

        my %hash;
        my $depth = 0;
        my $in_string = 0;
        my $current = '';

        for my $char (split //, $content) {
            if ($char eq '"' && ($current eq '' || substr($current, -1) ne '\\')) {
                $in_string = !$in_string;
                $current .= $char;
            }
            elsif (!$in_string && ($char eq '[' || $char eq '{')) {
                $depth++;
                $current .= $char;
            }
            elsif (!$in_string && ($char eq ']' || $char eq '}')) {
                $depth--;
                $current .= $char;
            }
            elsif (!$in_string && $char eq ',' && $depth == 0) {
                if ($current =~ /^\s*"([^"]+)"\s*:\s*(.+)$/s) {
                    my ($key, $value) = ($1, $2);
                    $value =~ s/^\s+|\s+$//g;
                    $hash{$key} = $self->_decode($value);
                }
                $current = '';
            }
            else {
                $current .= $char;
            }
        }

        if ($current ne '' && $current =~ /^\s*"([^"]+)"\s*:\s*(.+)$/s) {
            my ($key, $value) = ($1, $2);
            $value =~ s/^\s+|\s+$//g;
            $hash{$key} = $self->_decode($value);
        }

        return \%hash;
    }

    die "Cannot decode JSON: $json";
}

# Boolean package for proper true/false encoding
package LocalCode::JSON::Boolean;
use overload
    '""' => sub { ${$_[0]} ? 'true' : 'false' },
    '0+' => sub { ${$_[0]} ? 1 : 0 },
    'bool' => sub { ${$_[0]} },
    fallback => 1;

1;

# END INLINED MODULE: LocalCode::JSON

# BEGIN INLINED MODULE: LocalCode::HTTP
package LocalCode::HTTP;
use Socket;
use IO::Socket::INET;

# Minimal HTTP client - no external dependencies
# Supports GET and POST requests to localhost (Ollama)

sub new {
    my ($class, %args) = @_;
    return bless {
        timeout => $args{timeout} || 120,
    }, $class;
}

sub get {
    my ($self, $url) = @_;
    return $self->_request('GET', $url);
}

sub post {
    my ($self, $url, %args) = @_;
    return $self->_request('POST', $url, %args);
}

sub _request {
    my ($self, $method, $url, %args) = @_;

    # Parse URL
    my ($proto, $host, $port, $path) = $url =~ m{^(https?)://([^:/ ]+):?(\d*)(.*)$};
    $port ||= ($proto eq 'https' ? 443 : 80);
    $path ||= '/';

    # Create socket
    my $socket = IO::Socket::INET->new(
        PeerAddr => $host,
        PeerPort => $port,
        Proto    => 'tcp',
        Timeout  => $self->{timeout},
    ) or return $self->_error("Connection failed: $!");

    # Build HTTP request
    my $request = "$method $path HTTP/1.1\r\n";
    $request .= "Host: $host:$port\r\n";
    $request .= "User-Agent: LocalCode/1.0\r\n";
    $request .= "Connection: close\r\n";

    if ($method eq 'POST' && $args{Content}) {
        my $content = $args{Content};
        my $content_type = $args{'Content-Type'} || 'application/json';
        $request .= "Content-Type: $content_type\r\n";
        $request .= "Content-Length: " . length($content) . "\r\n";
        $request .= "\r\n";
        $request .= $content;
    } else {
        $request .= "\r\n";
    }

    # Send request
    print $socket $request;

    # Read response
    my $response = '';
    while (my $line = <$socket>) {
        $response .= $line;
    }
    close $socket;

    return $self->_parse_response($response);
}

sub _parse_response {
    my ($self, $response) = @_;

    # Split headers and body
    my ($headers, $body) = split /\r?\n\r?\n/, $response, 2;

    # Parse status line
    my ($status_line, @header_lines) = split /\r?\n/, $headers;

    # Extract status code and message
    my $code = 500;
    my $message = 'Unknown Error';

    if ($status_line && $status_line =~ /^HTTP\/[\d.]+\s+(\d+)\s*(.*)$/) {
        $code = int($1);  # Force numeric
        $message = $2 || 'OK';
    }

    # Check for chunked transfer encoding
    if ($headers =~ /Transfer-Encoding:\s*chunked/i && $body) {
        $body = $self->_decode_chunked($body);
    }

    # Create response object
    return bless {
        code => $code,
        message => $message,
        content => $body || '',
        headers => $headers,
        success => ($code >= 200 && $code < 300),
    }, 'LocalCode::HTTP::Response';
}

sub _decode_chunked {
    my ($self, $chunked_body) = @_;

    my $decoded = '';
    my @lines = split /\r?\n/, $chunked_body;

    my $i = 0;
    while ($i < @lines) {
        my $chunk_size_line = $lines[$i++];

        # Parse chunk size (hex)
        my ($chunk_size) = $chunk_size_line =~ /^([0-9a-fA-F]+)/;
        last unless defined $chunk_size;

        my $size = hex($chunk_size);
        last if $size == 0;  # Last chunk

        # Read chunk data (may span multiple lines)
        my $chunk_data = '';
        while ($i < @lines && length($chunk_data) < $size) {
            $chunk_data .= $lines[$i++];
            $chunk_data .= "\n" if length($chunk_data) < $size && $i < @lines;
        }

        $decoded .= substr($chunk_data, 0, $size);
    }

    return $decoded;
}

sub _error {
    my ($self, $error) = @_;
    return bless {
        code => 500,
        message => $error,
        content => '',
        success => 0,
    }, 'LocalCode::HTTP::Response';
}

package LocalCode::HTTP::Response;
use strict;
use warnings;

sub is_success {
    my ($self) = @_;
    return $self->{success};
}

sub code {
    my ($self) = @_;
    return $self->{code};
}

sub message {
    my ($self) = @_;
    return $self->{message};
}

sub status_line {
    my ($self) = @_;
    return "$self->{code} $self->{message}";
}

sub content {
    my ($self) = @_;
    return $self->{content};
}

1;

# END INLINED MODULE: LocalCode::HTTP

# BEGIN INLINED MODULE: LocalCode::ReadLine
package LocalCode::ReadLine;
use File::Spec;

# Term::ReadLine wrapper with fallback to simple readline
# Tries to use Term::ReadLine::Gnu if available for full features

sub new {
    my ($class, $name) = @_;

    my $self = bless {
        name => $name,
        history => [],
        history_file => undef,
        completion_function => undef,
        attribs => undef,
        term => undef,
        use_term_readline => 0,
    }, $class;

    # Try to load Term::ReadLine (comes with Perl core)
    eval {
        require Term::ReadLine;
        $self->{term} = Term::ReadLine->new($name);
        $self->{use_term_readline} = 1;
        $self->{attribs} = $self->{term}->Attribs if $self->{term}->can('Attribs');
    };

    # If Term::ReadLine failed, use fallback attribs
    if ($@ || !$self->{attribs}) {
        $self->{use_term_readline} = 0;
        $self->{attribs} = LocalCode::ReadLine::Attribs->new();
    }

    return $self;
}

sub readline {
    my ($self, $prompt) = @_;

    # Use Term::ReadLine if available (gives us history, tab completion, etc.)
    if ($self->{use_term_readline} && $self->{term}) {
        my $input = $self->{term}->readline($prompt);
        return undef unless defined $input;
        chomp $input if defined $input;
        return $input;
    }

    # Fallback: Simple approach using standard Perl input
    print $prompt if $prompt;
    my $input = <STDIN>;
    return undef unless defined $input;
    chomp $input;
    return $input;
}

sub add_history {
    my ($self, $line) = @_;
    return unless defined $line && $line ne '';

    # Use Term::ReadLine's history if available
    if ($self->{use_term_readline} && $self->{term}) {
        $self->{term}->addhistory($line);
        return;
    }

    # Fallback: Store in our own history array
    return if @{$self->{history}} && $self->{history}->[-1] eq $line;
    push @{$self->{history}}, $line;
}

sub ReadHistory {
    my ($self, $file) = @_;
    $self->{history_file} = $file;

    return unless -f $file;

    # Use Term::ReadLine's history file support if available
    if ($self->{use_term_readline} && $self->{term} && $self->{term}->can('ReadHistory')) {
        $self->{term}->ReadHistory($file);
        return;
    }

    # Fallback: Read history manually
    open my $fh, '<', $file or return;
    while (my $line = <$fh>) {
        chomp $line;
        $self->add_history($line) if $line ne '';
    }
    close $fh;
}

sub WriteHistory {
    my ($self, $file) = @_;
    $file ||= $self->{history_file};
    return unless $file;

    # Use Term::ReadLine's history file support if available
    if ($self->{use_term_readline} && $self->{term} && $self->{term}->can('WriteHistory')) {
        $self->{term}->WriteHistory($file);
        return;
    }

    # Fallback: Write history manually
    open my $fh, '>', $file or return;
    for my $line (@{$self->{history}}) {
        print $fh "$line\n";
    }
    close $fh;
}

sub clear_history {
    my ($self) = @_;
    $self->{history} = [];
}

sub ornaments {
    my ($self, $value) = @_;
    # Ignore ornaments - we don't support them
    return 0;
}

sub Attribs {
    my ($self) = @_;
    # Return Term::ReadLine's attribs if available
    if ($self->{use_term_readline} && $self->{term} && $self->{term}->can('Attribs')) {
        return $self->{term}->Attribs;
    }
    return $self->{attribs};
}

package LocalCode::ReadLine::Attribs;
use strict;
use warnings;

# Minimal attribs object for compatibility

sub new {
    my ($class) = @_;
    return bless {
        completion_function => undef,
        keymap => 'emacs',
    }, $class;
}

1;

# END INLINED MODULE: LocalCode::ReadLine

# BEGIN INLINED MODULE: LocalCode::Config
package LocalCode::Config;
use File::Spec;
use File::Path qw(make_path);

our $VERSION = '1.2.0';

sub new {
    my ($class, %args) = @_;
    my $self = {
        config_file => $args{config_file} || 'config/default.yaml',
        config_data => {},
        home_dir => $ENV{HOME} || $ENV{USERPROFILE} || '.',
        localcode_dir => undef,
    };
    bless $self, $class;
    
    # Create ~/.localcode directory structure
    $self->{localcode_dir} = File::Spec->catdir($self->{home_dir}, '.localcode');
    $self->_ensure_localcode_dir();
    
    $self->_load_config();
    return $self;
}

sub load_defaults {
    my ($self) = @_;
    my $default_file = 'config/default.yaml';
    return $self->load_file($default_file);
}

sub load_file {
    my ($self, $file) = @_;
    return {} unless -f $file;
    
    my $yaml = LocalCode::YAML->read($file);
    return {} unless $yaml && $yaml->[0];
    
    my $config = $yaml->[0];
    
    # Convert YAML boolean strings to Perl boolean
    $self->_convert_booleans($config);
    
    return $config;
}

sub _convert_booleans {
    my ($self, $data) = @_;
    return unless ref $data;
    
    if (ref $data eq 'HASH') {
        for my $key (keys %$data) {
            if (ref $data->{$key}) {
                $self->_convert_booleans($data->{$key});
            } elsif (defined $data->{$key}) {
                if ($data->{$key} eq 'true') {
                    $data->{$key} = 1;
                } elsif ($data->{$key} eq 'false') {
                    $data->{$key} = 0;
                }
            }
        }
    } elsif (ref $data eq 'ARRAY') {
        for my $item (@$data) {
            $self->_convert_booleans($item);
        }
    }
}

sub _load_config {
    my ($self) = @_;
    $self->{config_data} = $self->load_file($self->{config_file});
    
    # Merge with defaults if not using default file
    if ($self->{config_file} ne 'config/default.yaml') {
        my $defaults = $self->load_defaults();
        $self->{config_data} = $self->merge($defaults, $self->{config_data});
    }
}

sub validate {
    my ($self, $config) = @_;
    $config ||= $self->{config_data};
    
    return 0 unless ref $config eq 'HASH';
    return 0 unless $config->{ollama};
    return 0 unless defined $config->{ollama}->{host};
    return 0 unless $config->{ollama}->{port} && $config->{ollama}->{port} =~ /^\d+$/;
    
    return 1;
}

# Home directory management
sub _ensure_localcode_dir {
    my ($self) = @_;
    
    unless (-d $self->{localcode_dir}) {
        make_path($self->{localcode_dir}) or die "Cannot create ~/.localcode directory: $!";
    }
    
    # Create subdirectories
    my $sessions_dir = File::Spec->catdir($self->{localcode_dir}, 'sessions');
    make_path($sessions_dir) unless -d $sessions_dir;
}

sub get_localcode_dir {
    my ($self) = @_;
    return $self->{localcode_dir};
}

sub get_sessions_dir {
    my ($self) = @_;
    return File::Spec->catdir($self->{localcode_dir}, 'sessions');
}


sub save_last_model {
    my ($self, $model) = @_;
    my $model_file = File::Spec->catfile($self->{localcode_dir}, 'last_model.txt');
    
    # Trim whitespace before saving
    $model =~ s/^\s+|\s+$//g if $model;
    
    open my $fh, '>', $model_file or warn "Cannot save last model: $!";
    print $fh $model if $fh;
    close $fh if $fh;
}

sub load_last_model {
    my ($self) = @_;
    my $model_file = File::Spec->catfile($self->{localcode_dir}, 'last_model.txt');
    
    return '' unless -f $model_file;
    
    open my $fh, '<', $model_file or return '';
    my $model = <$fh>;
    close $fh;
    
    if ($model) {
        chomp $model;
        $model =~ s/^\s+|\s+$//g;  # Trim whitespace
    }
    return $model || '';
}

sub get_version {
    my ($self) = @_;
    return $VERSION;
}

sub merge {
    my ($self, $defaults, $custom) = @_;
    my %merged = %$defaults;
    
    for my $key (keys %$custom) {
        if (ref $custom->{$key} eq 'HASH' && ref $defaults->{$key} eq 'HASH') {
            $merged{$key} = $self->merge($defaults->{$key}, $custom->{$key});
        } else {
            $merged{$key} = $custom->{$key};
        }
    }
    
    return \%merged;
}

sub get {
    my ($self, $path) = @_;
    my @keys = split /\./, $path;
    my $data = $self->{config_data};
    
    for my $key (@keys) {
        return unless ref $data eq 'HASH' && exists $data->{$key};
        $data = $data->{$key};
    }
    
    return $data;
}

sub set {
    my ($self, $path, $value) = @_;
    my @keys = split /\./, $path;
    my $data = $self->{config_data};
    
    for my $i (0 .. $#keys - 1) {
        my $key = $keys[$i];
        $data->{$key} = {} unless ref $data->{$key} eq 'HASH';
        $data = $data->{$key};
    }
    
    $data->{$keys[-1]} = $value;
}

sub set_testing_mode {
    my ($self, $mode) = @_;
    
    # Reset all testing flags
    $self->set('testing.auto_approve', 0);
    $self->set('testing.auto_deny', 0);
    $self->set('testing.simulate_only', 0);
    $self->set('testing.mock_execution', 0);
    
    if ($mode eq 'auto_yes') {
        $self->set('testing.auto_approve', 1);
    } elsif ($mode eq 'auto_no') {
        $self->set('testing.auto_deny', 1);
    } elsif ($mode eq 'simulate') {
        $self->set('testing.simulate_only', 1);
    } elsif ($mode eq 'mock') {
        $self->set('testing.mock_execution', 1);
    }
}

1;
# END INLINED MODULE: LocalCode::Config

# BEGIN INLINED MODULE: LocalCode::Client
package LocalCode::Client;
sub new {
    my ($class, %args) = @_;
    my $self = {
        config => $args{config},
        host => $args{host} || 'localhost',
        port => $args{port} || 11434,
        timeout => $args{timeout} || 120,
        current_model => undef,
        default_model => 'codellama:latest',
        available_models => [],
        mock_mode => 0,
        mock_models => [],
        ua => LocalCode::HTTP->new(timeout => $args{timeout} || 120),
        status => 'disconnected',
        # Context tracking
        context_window => 0,      # num_ctx from model
        prompt_tokens => 0,        # prompt_eval_count
        completion_tokens => 0,    # eval_count
        total_tokens => 0,         # prompt_tokens + completion_tokens
    };
    bless $self, $class;
    
    if ($self->{config}) {
        $self->{host} = $self->{config}->get('ollama.host') || $self->{host};
        $self->{port} = $self->{config}->get('ollama.port') || $self->{port};
        $self->{default_model} = $self->{config}->get('ollama.default_model') || $self->{default_model};
        $self->{timeout} = $self->{config}->get('ollama.timeout') || $self->{timeout};
    }
    
    return $self;
}

sub connect {
    my ($self) = @_;
    
    if ($self->{mock_mode}) {
        $self->{status} = 'connected';
        $self->detect_available_models();
        $self->initialize_current_model();
        return 1;
    }
    
    my $url = "http://$self->{host}:$self->{port}/api/tags";
    my $response = $self->{ua}->get($url);
    
    if ($response->is_success) {
        $self->{status} = 'connected';
        $self->detect_available_models();
        $self->initialize_current_model();
        return 1;
    }
    
    $self->{status} = 'disconnected';
    return 0;
}

sub disconnect {
    my ($self) = @_;
    $self->{status} = 'disconnected';
}

sub get_status {
    my ($self) = @_;
    return $self->{status};
}

sub detect_available_models {
    my ($self) = @_;
    
    if ($self->{mock_mode}) {
        $self->{available_models} = [@{$self->{mock_models}}];
        return @{$self->{available_models}};
    }
    
    my $url = "http://$self->{host}:$self->{port}/api/tags";
    my $response = $self->{ua}->get($url);
    
    if ($response->is_success) {
        my $data = eval { LocalCode::JSON->new->decode($response->content) };
        if ($data && $data->{models}) {
            $self->{available_models} = [map { $_->{name} } @{$data->{models}}];
        }
    }
}

sub list_models {
    my ($self) = @_;
    
    # Auto-detect models if not done yet
    if (@{$self->{available_models}} == 0 && $self->{mock_mode}) {
        $self->detect_available_models();
    }
    
    # Return alphabetically sorted models
    return sort @{$self->{available_models}};
}

sub validate_model {
    my ($self, $model) = @_;
    
    # Auto-detect models if not done yet
    if (@{$self->{available_models}} == 0 && $self->{mock_mode}) {
        $self->detect_available_models();
    }
    
    return grep { $_ eq $model } @{$self->{available_models}};
}

sub is_model_available {
    my ($self, $model) = @_;
    return $self->validate_model($model);
}

sub set_default_model {
    my ($self, $model) = @_;
    $self->{default_model} = $model;
    return 1;
}

sub get_default_model {
    my ($self) = @_;
    return $self->{default_model};
}

sub initialize_current_model {
    my ($self) = @_;
    
    # Use current_model from config if available and valid
    if ($self->{config}) {
        my $config_model = $self->{config}->get('ollama.current_model');
        if ($config_model && $self->validate_model($config_model)) {
            $self->{current_model} = $config_model;
            return 1;
        }
    }
    
    # Fall back to default model
    if ($self->validate_model($self->{default_model})) {
        $self->{current_model} = $self->{default_model};
        return 1;
    }
    
    # Use first available model
    if (@{$self->{available_models}}) {
        $self->{current_model} = $self->{available_models}->[0];
        return 1;
    }
    
    return 0;
}

sub set_model {
    my ($self, $model) = @_;
    
    if ($self->validate_model($model)) {
        $self->{current_model} = $model;
        return 1;
    }
    
    # For invalid models, don't fallback - just return false
    return 0;
}

sub get_current_model {
    my ($self) = @_;
    return $self->{current_model};
}

sub restore_model {
    my ($self, $model) = @_;
    return $self->set_model($model);
}

sub chat {
    my ($self, $prompt, $model, $messages) = @_;
    
    $model ||= $self->{current_model};
    return "Error: No model selected" unless $model;
    
    if ($self->{mock_mode}) {
        # Simulate timeout for testing
        if ($self->{timeout} <= 1 && $prompt =~ /slow/i) {
            return "Error: Request timeout after $self->{timeout} seconds";
        }
        return "mock response from $model: $prompt";
    }
    
    my $url = "http://$self->{host}:$self->{port}/api/chat";
    my $payload = {
        model => $model,
        messages => $messages || [{ role => 'user', content => $prompt }],
        stream => $LocalCode::JSON::false,  # false boolean in JSON
    };
    
    # Call the common chat implementation
    return $self->_chat_request($url, $payload);
}


sub _chat_request {
    my ($self, $url, $payload) = @_;
    
    my $model = $payload->{model};  # Get model from payload
    
    my $response = $self->{ua}->post(
        $url,
        'Content-Type' => 'application/json',
        Content => LocalCode::JSON->new->encode($payload)
    );
    
    if ($response->is_success) {
        my $data = eval { LocalCode::JSON->new->decode($response->content) };
        if ($data) {
            # Update context tracking from response
            $self->{prompt_tokens} = $data->{prompt_eval_count} || 0;
            $self->{completion_tokens} = $data->{eval_count} || 0;
            $self->{total_tokens} = $self->{prompt_tokens} + $self->{completion_tokens};

            # Handle different Ollama response formats
            if ($data->{message} && exists $data->{message}->{content}) {
                my $content = $data->{message}->{content};

                # For gpt-oss models, include thinking if available
                if ($model =~ /gpt-oss/ && $data->{message}->{thinking}) {
                    $content = "**Thinking...**\n" . $data->{message}->{thinking} . "\n\n**Response:**\n" . $content;
                }

                return $content;
            } elsif ($data->{response}) {
                # Fallback to old /api/generate format
                return $data->{response};
            } elsif (exists $data->{content}) {
                # Another possible format - check for thinking field too
                my $content = $data->{content};
                if ($model =~ /gpt-oss/ && $data->{thinking}) {
                    $content = "**Thinking...**\n" . $data->{thinking} . "\n\n**Response:**\n" . $content;
                }
                return $content;
            } else {
                # Debug: show what we actually got
                return "Error: Unexpected response format. Got: " . substr($response->content, 0, 200) . "...";
            }
        } else {
            return "Error: Invalid JSON response from Ollama";
        }
    }
    
    # Check for context length exceeded error
    if (!$response->is_success) {
        my $error_data = eval { LocalCode::JSON->new->decode($response->content) };
        if ($error_data && $error_data->{error} && $error_data->{error} =~ /context length exceeded/i) {
            return { error => 'context_length_exceeded', raw_error => $error_data->{error} };
        }
    }
    
    # Handle timeout
    if ($response->code == 500 && $response->message =~ /timeout/i) {
        return "Error: Request timeout after $self->{timeout} seconds";
    }
    
    return "Error: " . $response->status_line;
}


sub generate {
    my ($self, $prompt) = @_;
    return $self->chat($prompt);
}

# Get model information including context window size
sub get_model_info {
    my ($self, $model) = @_;

    $model ||= $self->{current_model};
    return undef unless $model;

    if ($self->{mock_mode}) {
        return {
            num_ctx => 4096,  # Mock context window
            model => $model,
        };
    }

    my $url = "http://$self->{host}:$self->{port}/api/show";
    my $payload = {
        name => $model,
    };

    my $response = $self->{ua}->post(
        $url,
        'Content-Type' => 'application/json',
        Content => LocalCode::JSON->new->encode($payload)
    );

    if ($response->is_success) {
        my $data = eval { LocalCode::JSON->new->decode($response->content) };
        if ($data) {
            # Extract num_ctx from various possible locations in Ollama response
            my $num_ctx = 4096;  # Default fallback

            # Try different paths where num_ctx might be
            if ($data->{model_info} && $data->{model_info}->{num_ctx}) {
                $num_ctx = $data->{model_info}->{num_ctx};
            } elsif ($data->{model_info} && ref($data->{model_info}) eq 'HASH') {
                # Look for 'num_ctx' in any nested structure
                for my $key (keys %{$data->{model_info}}) {
                    if (ref($data->{model_info}->{$key}) eq 'HASH' && $data->{model_info}->{$key}->{num_ctx}) {
                        $num_ctx = $data->{model_info}->{$key}->{num_ctx};
                        last;
                    }
                }
            }

            # Store it for this model
            $self->{context_window} = $num_ctx;

            return {
                num_ctx => $num_ctx,
                model => $model,
                data => $data,
            };
        }
    }

    # Even if request fails, set a default context window
    $self->{context_window} = 4096;
    return undef;
}

# Get context usage statistics
sub get_context_stats {
    my ($self) = @_;

    return {
        context_window => $self->{context_window} || 0,
        prompt_tokens => $self->{prompt_tokens} || 0,
        completion_tokens => $self->{completion_tokens} || 0,
        total_tokens => $self->{total_tokens} || 0,
        percentage => $self->{context_window} > 0
            ? int(($self->{total_tokens} / $self->{context_window}) * 100)
            : 0,
    };
}


1;
# END INLINED MODULE: LocalCode::Client

# BEGIN INLINED MODULE: LocalCode::Tools
package LocalCode::Tools;
sub new {
    my ($class, %args) = @_;
    my $self = {
        config => $args{config},
        tools => {},
        permissions => $args{permissions},
        timeout => $args{timeout} || 60,
        test_mode => 0,
        auto_approve => 0,
        mock_execution => 0,
        simulate_only => 0,
        # Browser state for web tools
        browser_pages => {},
        browser_stack => [],
        current_page_id => 0,
    };
    bless $self, $class;
    
    # Register default tools
    $self->_register_default_tools();
    
    return $self;
}

sub _register_default_tools {
    my ($self) = @_;
    
    $self->register_tool('read', 0, \&_tool_read);
    $self->register_tool('write', 1, \&_tool_write);
    $self->register_tool('exec', 1, \&_tool_exec);
    $self->register_tool('bash', 1, \&_tool_exec);  # bash = exec alias
    $self->register_tool('search', 0, \&_tool_search);
    $self->register_tool('grep', 0, \&_tool_search);  # grep = search alias
    $self->register_tool('edit', 1, \&_tool_edit);
    $self->register_tool('list', 0, \&_tool_list);
    $self->register_tool('glob', 0, \&_tool_glob);
    $self->register_tool('patch', 1, \&_tool_patch);
    $self->register_tool('webfetch', 0, \&_tool_webfetch);
    $self->register_tool('websearch', 0, \&_tool_websearch);
    $self->register_tool('webopen', 0, \&_tool_webopen);
    $self->register_tool('webfind', 0, \&_tool_webfind);
    $self->register_tool('webget', 0, \&_tool_webget);
    $self->register_tool('todowrite', 0, \&_tool_todowrite);
    $self->register_tool('todoread', 0, \&_tool_todoread);
    $self->register_tool('task', 1, \&_tool_task);
}

sub register_tool {
    my ($self, $name, $permission_level, $handler) = @_;
    
    $self->{tools}->{$name} = {
        name => $name,
        permission_level => $permission_level,
        handler => $handler,
    };
}

sub list_tools {
    my ($self) = @_;
    return keys %{$self->{tools}};
}

sub validate_tool {
    my ($self, $name) = @_;
    return exists $self->{tools}->{$name};
}

sub check_permission {
    my ($self, $name) = @_;
    return $self->{tools}->{$name}->{permission_level} if exists $self->{tools}->{$name};
    return 2; # BLOCKED for unknown tools
}

sub request_permission {
    my ($self, $name, $args) = @_;
    
    # Safe tools are auto-allowed
    return 1 if $self->check_permission($name) == 0;
    
    # In test mode with auto_approve
    return 1 if $self->{test_mode} && $self->{auto_approve};
    
    # In test mode without auto_approve
    return 0 if $self->{test_mode} && !$self->{auto_approve};
    
    # Default deny for dangerous tools
    return 0;
}

sub execute_tool {
    my ($self, $name, $args) = @_;
    
    # Validate tool exists
    unless ($self->validate_tool($name)) {
        return {
            success => 0,
            error => "Unknown tool: $name"
        };
    }
    
    # Skip permission check here - it's done in bin/localcode
    
    # Validate arguments (allow empty args for some tools like todoread)
    unless ($args && ref $args eq 'ARRAY') {
        return {
            success => 0,
            error => "Invalid arguments for tool: $name"
        };
    }
    
    # Some tools don't need arguments
    if (@$args == 0 && $name ne 'todoread') {
        return {
            success => 0,
            error => "Invalid arguments for tool: $name"
        };
    }
    
    # Simulation mode
    if ($self->{simulate_only}) {
        return {
            success => 1,
            output => "[SIMULATE] $name(" . join(', ', @$args) . ") -> Would execute"
        };
    }
    
    # Mock execution mode (bypasses permission for testing)
    if ($self->{mock_execution}) {
        return {
            success => 1,
            output => "mock " . lc($name) . ": " . join(', ', @$args)
        };
    }
    
    # Execute the tool
    my $tool = $self->{tools}->{$name};
    
    # Simulate timeout for testing
    if ($self->{test_mode} && $self->{timeout} <= 1 && $args->[0] && $args->[0] =~ /sleep/) {
        return {
            success => 0,
            error => "Tool timeout after $self->{timeout} seconds"
        };
    }
    
    my $result = eval {
        # Browser tools need $self reference, others don't
        if ($name =~ /^web(search|open|find|get)$/) {
            $tool->{handler}->($self, @$args);
        } else {
            $tool->{handler}->(@$args);
        }
    };
    
    if ($@) {
        return {
            success => 0,
            error => "Tool execution failed: $@"
        };
    }
    
    # If result is already a proper hash with success/error, return it directly
    if (ref $result eq 'HASH' && (exists $result->{success} || exists $result->{error})) {
        return $result;
    }
    
    # Otherwise wrap simple results
    return {
        success => 1,
        output => $result
    };
}

# Tool implementations
sub _tool_read {
    my ($file) = @_;
    
    unless (-f $file) {
        return {
            success => 0,
            error => "File not found: $file"
        };
    }
    
    open my $fh, '<', $file or return {
        success => 0,
        error => "Cannot read file: $!"
    };
    
    my $content = do { local $/; <$fh> };
    close $fh;
    
    return {
        success => 1,
        message => "Read " . length($content) . " bytes from $file",
        content => $content
    };
}

sub _tool_write {
    my ($file, $content) = @_;
    
    open my $fh, '>', $file or return {
        success => 0,
        error => "Cannot write file: $!"
    };
    
    # Add newline at end if content doesn't already end with one
    $content .= "\n" unless $content =~ /\n$/;
    
    print $fh $content;
    close $fh;
    
    return {
        success => 1,
        message => "Wrote " . length($content) . " bytes to $file"
    };
}

sub _tool_exec {
    my ($command) = @_;

    # Check execution permissions before attempting to run
    # Parse command to extract the file being executed
    my $file_to_execute;

    # Handle different command patterns:
    # - ./script.pl
    # - perl script.pl
    # - /path/to/script
    # - script (in PATH)

    if ($command =~ /^\s*\.\/(\S+)/) {
        # Relative path execution: ./script.pl
        $file_to_execute = "./$1";
    } elsif ($command =~ /^\s*(\S+)/) {
        # Extract first word/token which might be a file or command
        my $cmd_token = $1;

        # If it looks like a path (contains / or has file extension) and exists as a file
        if (($cmd_token =~ /\// || $cmd_token =~ /\.\w+$/) && -f $cmd_token) {
            $file_to_execute = $cmd_token;
        }
        # Check for interpreter patterns like "perl script.pl"
        elsif ($command =~ /^\s*(?:perl|python|ruby|bash|sh|node)\s+(\S+)/) {
            $file_to_execute = $1 if -f $1;
        }
        # Check if it's just a local file without path separator
        elsif (-f $cmd_token) {
            $file_to_execute = $cmd_token;
        }
        # Otherwise let it proceed (might be in PATH or will fail naturally)
    }

    # If we identified a local file to execute, check its permissions
    if ($file_to_execute && -f $file_to_execute) {
        # Check if file is executable
        unless (-x $file_to_execute) {
            # Get detailed file permissions
            my @stat_info = stat($file_to_execute);
            my $mode = $stat_info[2];
            my $uid = $stat_info[4];
            my $gid = $stat_info[5];

            # Format permissions in readable format (e.g., rw-r--r--)
            my $perms = sprintf("%04o", $mode & 07777);  # Octal permissions
            my $readable_perms = '';

            # Convert to rwx format
            my $octal = $mode & 0777;
            for my $i (0..2) {
                my $shift = (2 - $i) * 3;
                my $bits = ($octal >> $shift) & 7;
                $readable_perms .= ($bits & 4) ? 'r' : '-';
                $readable_perms .= ($bits & 2) ? 'w' : '-';
                $readable_perms .= ($bits & 1) ? 'x' : '-';
            }

            # Get current user info
            my $current_uid = $<;
            my $current_user = getpwuid($current_uid) || $current_uid;
            my $file_owner = getpwuid($uid) || $uid;
            my $file_group = getgrgid($gid) || $gid;

            # Build detailed error message in English
            my $error_msg = "EXECUTION DENIED: File '$file_to_execute' does not have execute permission.\n\n";
            $error_msg .= "Current permissions: $readable_perms ($perms in octal)\n";
            $error_msg .= "File owner: $file_owner (uid: $uid)\n";
            $error_msg .= "File group: $file_group (gid: $gid)\n";
            $error_msg .= "Current user: $current_user (uid: $current_uid)\n\n";
            $error_msg .= "To fix this, you need to add execute permission. Suggested fix:\n";
            $error_msg .= "  chmod +x $file_to_execute\n\n";
            $error_msg .= "Alternative: Run the file with an interpreter:\n";

            # Suggest appropriate interpreter based on file extension or shebang
            if ($file_to_execute =~ /\.pl$/) {
                $error_msg .= "  perl $file_to_execute";
            } elsif ($file_to_execute =~ /\.py$/) {
                $error_msg .= "  python $file_to_execute";
            } elsif ($file_to_execute =~ /\.rb$/) {
                $error_msg .= "  ruby $file_to_execute";
            } elsif ($file_to_execute =~ /\.sh$/) {
                $error_msg .= "  bash $file_to_execute";
            } elsif ($file_to_execute =~ /\.js$/) {
                $error_msg .= "  node $file_to_execute";
            } else {
                # Try to detect shebang
                if (open my $fh, '<', $file_to_execute) {
                    my $first_line = <$fh>;
                    close $fh;
                    if ($first_line && $first_line =~ /^#!\s*(\S+)/) {
                        my $interpreter = $1;
                        $error_msg .= "  $interpreter $file_to_execute (based on shebang)";
                    } else {
                        $error_msg .= "  bash $file_to_execute (or appropriate interpreter)";
                    }
                }
            }

            return {
                success => 0,
                message => "File lacks execute permission",
                error => $error_msg,
                output => $error_msg
            };
        }
    }

    my $output = `$command 2>&1`;
    my $status = $?;

    # Proper exit code extraction
    my $exit_code = 0;
    if ($status == -1) {
        # Failed to execute
        return {
            success => 0,
            message => "Failed to execute command",
            error => "Failed to execute: $!",
            output => $output
        };
    } elsif ($status & 127) {
        # Died with signal
        my $signal = $status & 127;
        return {
            success => 0,
            message => "Command died with signal $signal",
            error => "Died with signal $signal",
            output => $output,
            exit_code => 128 + $signal
        };
    } else {
        # Normal exit
        $exit_code = $status >> 8;
    }

    # Build detailed error message if command failed
    my $message = $exit_code == 0 ? "Command executed successfully" : "Command failed with exit code $exit_code";

    # If there's output and command failed, include it in the error
    if ($exit_code != 0 && $output) {
        chomp $output;
        $message = "Command failed: $output";
    }

    return {
        success => $exit_code == 0,
        message => $message,
        output => $output,
        exit_code => $exit_code,
        error => $exit_code != 0 ? $output : undef
    };
}

sub _tool_search {
    my ($pattern, $file) = @_;
    
    unless (-f $file) {
        return {
            success => 0,
            error => "File not found: $file"
        };
    }
    
    open my $fh, '<', $file or return {
        success => 0,
        error => "Cannot read file: $!"
    };
    
    my @matches = ();
    my $line_num = 0;
    
    while (my $line = <$fh>) {
        $line_num++;
        if ($line =~ /$pattern/) {
            push @matches, "$line_num: $line";
        }
    }
    close $fh;
    
    return {
        success => 1,
        message => "Found " . scalar(@matches) . " matches in $file",
        matches => \@matches
    };
}

sub _tool_edit {
    my ($file, $old_string, $new_string) = @_;
    
    unless (-f $file) {
        return {
            success => 0,
            error => "File not found: $file"
        };
    }
    
    # Read file
    open my $fh, '<', $file or return {
        success => 0,
        error => "Cannot read file: $!"
    };
    my $content = do { local $/; <$fh> };
    close $fh;
    
    # Count occurrences for verification
    my $count = () = $content =~ /\Q$old_string\E/g;
    if ($count == 0) {
        return {
            success => 0,
            error => "String not found in file: '$old_string'"
        };
    }
    
    # Replace and write back
    $content =~ s/\Q$old_string\E/$new_string/g;
    
    open $fh, '>', $file or return {
        success => 0,
        error => "Cannot write file: $!"
    };
    print $fh $content;
    close $fh;
    
    return {
        success => 1,
        message => "Replaced $count occurrence(s) in $file"
    };
}

sub _tool_list {
    my ($path) = @_;
    
    unless (-d $path) {
        return {
            success => 0,
            error => "Directory not found: $path"
        };
    }
    
    opendir my $dh, $path or return {
        success => 0,
        error => "Cannot read directory: $!"
    };
    
    my @entries = sort grep { $_ ne '.' && $_ ne '..' } readdir $dh;
    closedir $dh;
    
    return {
        success => 1,
        message => "Found " . scalar(@entries) . " entries in $path",
        entries => \@entries
    };
}

sub _tool_glob {
    my ($pattern, $directory) = @_;
    $directory ||= '.';
    
    unless (-d $directory) {
        return {
            success => 0,
            error => "Directory not found: $directory"
        };
    }
    
    my @matches = glob("$directory/$pattern");
    
    return {
        success => 1,
        message => "Found " . scalar(@matches) . " matches for pattern '$pattern'",
        matches => \@matches
    };
}

sub _tool_patch {
    my ($file, $patch_content) = @_;
    
    unless (-f $file) {
        return {
            success => 0,
            error => "File not found: $file"
        };
    }
    
    # Create temporary patch file
    my $patch_file = "/tmp/localcode_patch_$$.patch";
    open my $fh, '>', $patch_file or return {
        success => 0,
        error => "Cannot create patch file: $!"
    };
    print $fh $patch_content;
    close $fh;
    
    # Apply patch
    my $output = `patch -p0 < $patch_file 2>&1`;
    my $exit_code = $? >> 8;
    
    unlink $patch_file;
    
    return {
        success => $exit_code == 0,
        message => $exit_code == 0 ? "Patch applied successfully" : "Patch failed",
        output => $output
    };
}

sub _tool_webfetch {
    my ($url) = @_;
    
    # Use curl for web fetching
    my $output = `curl -s -L "$url" 2>&1`;
    my $exit_code = $? >> 8;
    
    return {
        success => $exit_code == 0,
        message => $exit_code == 0 ? "Fetched content from $url" : "Failed to fetch from $url",
        content => $output
    };
}

sub _tool_webget {
    my $self = shift;
    my ($query) = @_;
    
    # Step 1: Search
    my $search_result = $self->_tool_websearch($query);
    unless ($search_result->{success}) {
        return $search_result;
    }
    
    # Step 2: Extract first good URL and open it
    my @urls = ($search_result->{content} =~ m{https?://[^\s<>"'()]+}g);
    
    # Clean up URLs
    @urls = map { 
        s/[.,;:!?)\]}>]*$//;  # Remove trailing punctuation
        s/#.*$//;             # Remove fragments
        $_; 
    } @urls;
    
    # Remove duplicates and keep valid URLs  
    my %seen;
    @urls = grep { !$seen{$_}++ && $_ =~ m{^https?://[^/\s]+} } @urls;
    
    unless (@urls) {
        return {
            success => 0,
            error => "No valid URLs found in search results"
        };
    }
    
    # Try the first few URLs until one works, preferring specific pages
    for my $i (0..4) {  # Try more URLs
        last unless $urls[$i];
        
        my $open_result = $self->_tool_webopen($urls[$i]);
        if ($open_result->{success}) {
            # Return the first working URL - no domain-specific filtering
            
            return {
                success => 1,
                message => "Found and opened webpage: $urls[$i]",
                content => $open_result->{content},
                search_query => $query,
                url => $urls[$i],
                page_id => $open_result->{page_id}
            };
        }
    }
    
    return {
        success => 0,
        error => "Could not open any of the found URLs"
    };
}

sub _tool_todowrite {
    my ($task_description) = @_;
    
    my $todo_file = '.localcode_todo.txt';
    my $timestamp = localtime();
    
    open my $fh, '>>', $todo_file or return {
        success => 0,
        error => "Cannot write to todo file: $!"
    };
    
    print $fh "[$timestamp] $task_description\n";
    close $fh;
    
    return {
        success => 1,
        message => "Added task to todo list: $task_description"
    };
}

sub _tool_todoread {
    my $todo_file = '.localcode_todo.txt';
    
    unless (-f $todo_file) {
        return {
            success => 1,
            message => "No todo file found",
            content => "No tasks yet"
        };
    }
    
    open my $fh, '<', $todo_file or return {
        success => 0,
        error => "Cannot read todo file: $!"
    };
    
    my $content = do { local $/; <$fh> };
    close $fh;
    
    return {
        success => 1,
        message => "Read todo list",
        content => $content || "Todo list is empty"
    };
}

sub _tool_task {
    my ($task_command) = @_;
    
    # Execute a complex task (essentially an exec with task context)
    my $output = `$task_command 2>&1`;
    my $exit_code = $? >> 8;
    
    return {
        success => $exit_code == 0,
        message => $exit_code == 0 ? "Task completed successfully" : "Task failed with exit code $exit_code",
        output => $output,
        exit_code => $exit_code
    };
}

# Browser Tools Implementation

# Simple URL encoding function (replaces URI::Escape)
sub _url_encode {
    my ($str) = @_;
    $str =~ s/([^A-Za-z0-9\-_.~])/sprintf("%%%02X", ord($1))/ge;
    return $str;
}

sub _tool_websearch {
    my $self = shift;
    my ($query) = @_;

    my $encoded_query = _url_encode($query);
    
    # Try multiple search engines - robust fallback system
    my @search_engines = (
        {
            name => "Mojeek",
            url => "https://www.mojeek.com/search?q=$encoded_query",
            user_agent => "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
        },
        {
            name => "DuckDuckGo HTML",
            url => "https://html.duckduckgo.com/html/?q=$encoded_query",
            user_agent => "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
        },
        {
            name => "Startpage",
            url => "https://www.startpage.com/sp/search?query=$encoded_query",
            user_agent => "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
        },
        {
            name => "Bing",
            url => "https://www.bing.com/search?q=$encoded_query",
            user_agent => "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
        }
    );
    
    my $html_content;
    my $used_engine;
    my $used_url;
    
    for my $engine (@search_engines) {
        my $cmd = qq{curl -s -k -A "$engine->{user_agent}" "$engine->{url}"};
        $html_content = `$cmd 2>/dev/null`;
        my $exit_code = $? >> 8;
        
        if ($exit_code == 0 && $html_content && length($html_content) > 500) {
            # Quick test for meaningful content
            my $test_content = $html_content;
            $test_content =~ s/<script.*?<\/script>//gsi;
            $test_content =~ s/<style.*?<\/style>//gsi;
            $test_content =~ s/<[^>]+>//g;
            $test_content =~ s/\s+/ /g;
            
            # If we got substantial cleaned content, use this engine
            if (length($test_content) > 300) {
                $used_engine = $engine->{name};
                $used_url = $engine->{url};
                last;
            }
        }
    }
    
    unless ($html_content && $used_engine) {
        return {
            success => 0,
            error => "All search engines failed - please check internet connection"
        };
    }
    
    # Clean HTML - remove scripts, styles, and convert to text
    $html_content =~ s/<script.*?<\/script>//gsi;
    $html_content =~ s/<style.*?<\/style>//gsi;
    $html_content =~ s/<noscript.*?<\/noscript>//gsi;
    $html_content =~ s/<!--.*?-->//gs;
    $html_content =~ s/<head.*?<\/head>//gsi;
    
    # Convert HTML entities
    $html_content =~ s/&nbsp;/ /g;
    $html_content =~ s/&amp;/&/g;
    $html_content =~ s/&lt;/</g;
    $html_content =~ s/&gt;/>/g;
    $html_content =~ s/&quot;/"/g;
    $html_content =~ s/&#39;/'/g;
    $html_content =~ s/&#8211;/-/g;
    $html_content =~ s/&#8212;/--/g;
    $html_content =~ s/&#x2715;/x/g;
    $html_content =~ s/&#(\d+);/chr($1)/ge;
    $html_content =~ s/&rsaquo;/>/g;
    
    # Remove all HTML tags
    $html_content =~ s/<[^>]+>//g;
    
    # Clean up whitespace and normalize
    $html_content =~ s/\r\n/\n/g;
    $html_content =~ s/\s+/ /g;
    $html_content =~ s/^\s+|\s+$//g;
    
    # Remove Mojeek-specific navigation noise
    $html_content =~ s/Mojeek User Survey.*?Results \d+ to \d+ from \d+.*?in \d+\.\d+s//gs;
    $html_content =~ s/(SearchWebImagesNewsSubstickCompanyPress|MediaCareersContact|UsProductsMojeekAdsFocusWeb|SearchAPISiteSearchAPI|SimpleSearchBoxes|SupportSupportBrowsersMobile|APIDocsEngageBlogCommunityNewsletter)//g;
    
    # Remove general navigation/footer noise
    $html_content =~ s/(Privacy|Terms|Settings|About|Help|Sign in|Advertisement|Cookie|JavaScript|Enable|Disable|Menu|Navigation|Header|Footer)(\s+\w+)*\s*//gi;
    $html_content =~ s/\b(More results|Related searches|People also ask|Submit feedback|Change|Prev|Next|WebSummaryImagesNews|United Kingdom|Germany|France|European Union|All Regions|Advanced Search|Preferences|Focus|Language None|Safe Search Off|Theme Light)\b\s*//gim;
    
    # Remove duplicate whitespace and clean up
    $html_content =~ s/\s+/ /g;
    $html_content =~ s/^\s+|\s+$//g;
    
    # If content is still too short, provide fallback message
    if (length($html_content) < 200) {
        $html_content = "Search performed for '$query' using $used_engine. Limited results available - search engines may be blocking automated requests. Try more specific search terms.";
    }
    
    # Truncate if too long but keep meaningful content
    if (length($html_content) > 4000) {
        # Try to truncate at sentence boundaries
        my $truncated = substr($html_content, 0, 3800);
        if ($truncated =~ /^(.*\.)\s+\w/) {
            $html_content = $1 . "\n\n[Search results truncated for readability...]";
        } else {
            $html_content = substr($html_content, 0, 3800) . "\n\n[Search results truncated for readability...]";
        }
    }
    
    # Store in browser state
    my $page_id = ++$self->{current_page_id};
    $self->{browser_pages}->{$page_id} = {
        title => "Search: $query",
        url => $used_url,
        content => $html_content,
        type => 'search',
        engine => $used_engine
    };
    push @{$self->{browser_stack}}, $page_id;
    
    # Format clean content for AI interpretation
    my $display = " Internet Search Results for: $query (via $used_engine)\n\n";
    $display .= $html_content . "\n\n";
    $display .= "[Note: These are real search results from $used_engine. Please extract and interpret the most relevant information.]";
    
    return {
        success => 1,
        message => "Retrieved search results from $used_engine",
        content => $display,
        page_id => $page_id,
        url => $used_url,
        engine => $used_engine
    };
}

sub _tool_webopen {
    my $self = shift;
    my ($url_or_id) = @_;
    
    # Use curl for better SSL support
    
    my $url;
    
    # Check if it's a result ID from search
    if ($url_or_id =~ /^\d+$/) {
        my $current_page = $self->{browser_stack}->[-1];
        if ($current_page && $self->{browser_pages}->{$current_page}) {
            my $page = $self->{browser_pages}->{$current_page};
            if ($page->{type} eq 'search') {
                # Extract URLs from cleaned content - get clean URLs
                my @urls = ($page->{content} =~ m{https?://[^\s<>"'()]+}g);
                
                # Clean up URLs - remove trailing punctuation and fragments
                @urls = map { 
                    s/[.,;:!?)\]}>]*$//;  # Remove trailing punctuation
                    s/#.*$//;             # Remove fragments
                    $_; 
                } @urls;
                
                # Remove duplicates and invalid URLs
                my %seen;
                @urls = grep { !$seen{$_}++ && $_ =~ m{^https?://[^/]+/} } @urls;
                
                my $result_id = int($url_or_id);
                if ($result_id < @urls) {
                    $url = $urls[$result_id];
                }
            }
        }
        
        unless ($url) {
            return {
                success => 0,
                error => "Invalid result ID: $url_or_id. Use webopen with a full URL instead."
            };
        }
    } else {
        $url = $url_or_id;
    }
    
    # Fetch the webpage using curl
    my $content = `curl -s -L -A "LocalCode/1.0" --max-time 30 -k "$url" 2>/dev/null`;
    my $exit_code = $? >> 8;
    
    if ($exit_code != 0) {
        return {
            success => 0,
            error => "Failed to fetch $url: curl exit code $exit_code"
        };
    }
    
    # Simple HTML to text conversion (basic)
    $content =~ s/<script.*?<\/script>//gsi;
    $content =~ s/<style.*?<\/style>//gsi;
    $content =~ s/<[^>]+>//g;
    $content =~ s/&nbsp;/ /g;
    $content =~ s/&amp;/&/g;
    $content =~ s/&lt;/</g;
    $content =~ s/&gt;/>/g;
    $content =~ s/\s+/ /g;
    
    # Truncate if too long
    if (length($content) > 8000) {
        $content = substr($content, 0, 8000) . "\n\n[Content truncated...]";
    }
    
    # Store page
    my $page_id = ++$self->{current_page_id};
    $self->{browser_pages}->{$page_id} = {
        title => 'Web Page',  # curl doesn't provide easy title extraction
        url => $url,
        content => $content,
        type => 'webpage'
    };
    push @{$self->{browser_stack}}, $page_id;
    
    return {
        success => 1,
        message => "Opened webpage: $url",
        content => $content,
        page_id => $page_id,
        url => $url
    };
}

sub _tool_webfind {
    my $self = shift;
    my ($pattern, $page_id) = @_;
    
    # Use current page if no ID specified
    $page_id ||= $self->{browser_stack}->[-1] if @{$self->{browser_stack}};
    
    unless ($page_id && $self->{browser_pages}->{$page_id}) {
        return {
            success => 0,
            error => "No webpage available to search"
        };
    }
    
    my $page = $self->{browser_pages}->{$page_id};
    my $content = $page->{content};
    
    my @matches = ();
    my @lines = split /\n/, $content;
    
    for my $i (0..$#lines) {
        if ($lines[$i] =~ /\Q$pattern\E/i) {
            my $context_start = $i > 2 ? $i - 2 : 0;
            my $context_end = $i + 2 < @lines ? $i + 2 : $#lines;
            
            my $match_context = join("\n", 
                map { sprintf("L%d: %s", $_ + 1, $lines[$_]) } 
                ($context_start..$context_end)
            );
            
            push @matches, {
                line => $i + 1,
                context => $match_context,
                text => $lines[$i]
            };
        }
    }
    
    my $result_text = " Find results for '$pattern' in " . $page->{title} . "\n\n";
    
    if (@matches) {
        $result_text .= sprintf("Found %d matches:\n\n", scalar(@matches));
        for my $i (0..($#matches < 9 ? $#matches : 9)) {  # Limit to 10 results
            my $match = $matches[$i];
            $result_text .= sprintf("[Match %d at line %d]\n%s\n\n", 
                $i + 1, $match->{line}, $match->{context});
        }
        
        if (@matches > 10) {
            $result_text .= sprintf("... and %d more matches\n", @matches - 10);
        }
    } else {
        $result_text .= "No matches found.\n";
    }
    
    return {
        success => 1,
        message => "Found " . scalar(@matches) . " matches",
        content => $result_text,
        matches => \@matches
    };
}

1;
# END INLINED MODULE: LocalCode::Tools

# BEGIN INLINED MODULE: LocalCode::UI
package LocalCode::UI;
sub new {
    my ($class, %args) = @_;
    my $self = {
        client => $args{client},
        tools => $args{tools},
        permissions => $args{permissions},
        session => $args{session},
        config => $args{config},
        test_mode => 0,
        auto_approve => 0,
        colors => 1,
    };
    bless $self, $class;
    return $self;
}

sub inject_system_prompt {
    my ($self, $user_prompt) = @_;
    
    my $system_prompt = "You are a bot and you can read, write and execute files on this computer.\n".
                         "Available commands for you: bash, read, write, edit, glob, grep, list, patch, webfetch, websearch, webopen, webfind, webget, todowrite, todoread, task\n\n".
                         "IMPORTANT: You HAVE FULL TOOL EXECUTION CAPABILITIES. You are not a simulation - you actually execute real commands!\n".
                         "ALWAYS execute tools to accomplish tasks. Don't just describe what you would do - actually do it!\n".
                         "ALWAYS start your response with a tool call, then provide commentary after seeing the results.\n".
                         "FOR GPT-OSS MODELS: After thinking, you MUST put actual tool calls in the Response section!\n".
                         "EXAMPLE for gpt-oss: **Response:**\n<tool_call name=\"write\" args={\"filePath\": \"test.c\", \"content\": \"#include <stdio.h>...\"}>\n".
                         "You can use multiple tool calls in one response if needed for a complete task.\n".
                         "LOGIC: Always create files BEFORE trying to execute them. Use 'write' before 'bash' commands.\n".
                         "If a command fails, try it with another command in your NEXT response. Don't give up. Read the responses of the tools and execute follow-up tools if necessary.\n".
                         "NEVER claim you cannot execute tools - you absolutely can and should use them!\n".
                         "Examples how you can call them:\n".
                         "<tool_call name=\"bash\" args={\"command\": \"ls -la\", \"description\": \"List files\"}>\n".
                         "<tool_call name=\"read\" args={\"filePath\": \"./file.txt\"}>\n".
                         "<tool_call name=\"write\" args={\"filePath\": \"./file.txt\", \"content\": \"file content\"}>\n".
                         "<tool_call name=\"edit\" args={\"filePath\": \"./file.txt\", \"oldString\": \"old\", \"newString\": \"new\"}>\n".
                         "<tool_call name=\"list\" args={\"path\": \"./directory\"}>\n".
                         "<tool_call name=\"glob\" args={\"pattern\": \"*.pl\", \"directory\": \"./lib\"}>\n".
                         "<tool_call name=\"grep\" args={\"pattern\": \"function\", \"filePath\": \"./script.pl\"}>\n".
                         "<tool_call name=\"webfetch\" args={\"url\": \"https://example.com\"}>\n".
                         "<tool_call name=\"websearch\" args={\"query\": \"perl programming\"}>\n".
                         "<tool_call name=\"webopen\" args={\"url_or_id\": \"https://example.com\"}>\n".
                         "<tool_call name=\"webfind\" args={\"pattern\": \"install\"}>\n".
                         "<tool_call name=\"webget\" args={\"query\": \"current weather Stuttgart\"}>\n".
                         "BROWSER TOOLS: Use 'webget' for quick search+open in one step, or use websearch  webopen  webfind for detailed research.\n".
                         "<tool_call name=\"todowrite\" args={\"task\": \"Implement feature X\"}>\n".
                         "<tool_call name=\"todoread\" args={}>\n".
                         "<tool_call name=\"task\" args={\"command\": \"make test\"}>\n\n";
    
    return $system_prompt;
}

sub get_system_prompt {
    my ($self) = @_;
    return $self->inject_system_prompt("");
}

sub _parse_json_args {
    my ($self, $args_str) = @_;
    my %args = ();
    
    return %args unless $args_str && $args_str =~ /\S/;
    
    # Parse JSON-like arguments with proper quote handling
    $args_str =~ s/^\s+|\s+$//g;  # Trim whitespace
    
    # Split by comma, but be careful about commas inside quoted strings
    my @pairs = ();
    my $current = '';
    my $quote_char = '';
    my $escape_next = 0;
    
    for my $char (split //, $args_str) {
        if ($escape_next) {
            $current .= $char;
            $escape_next = 0;
        } elsif ($char eq '\\') {
            $current .= $char;
            $escape_next = 1;
        } elsif ($char eq '"' || $char eq "'") {
            $current .= $char;
            if ($quote_char eq '') {
                $quote_char = $char;
            } elsif ($quote_char eq $char) {
                $quote_char = '';
            }
        } elsif ($char eq ',' && $quote_char eq '') {
            push @pairs, $current if $current =~ /\S/;
            $current = '';
        } else {
            $current .= $char;
        }
    }
    push @pairs, $current if $current =~ /\S/;
    
    # Parse each key: value pair
    for my $pair (@pairs) {
        if ($pair =~ /^\s*["']([^"']+)["']\s*:\s*["'](.*)["']\s*$/s) {
            my ($key, $value) = ($1, $2);
            # Unescape common escape sequences
            $value =~ s/\\n/\n/g;
            $value =~ s/\\t/\t/g;
            $value =~ s/\\"/"/g;
            $value =~ s/\\'/'/g;
            $value =~ s/\\\\/\\/g;
            $args{$key} = $value;
        }
    }
    
    return %args;
}

sub parse_tool_calls {
    my ($self, $response) = @_;
    my @tools = ();
    
    # Debug output if enabled
    if ($ENV{DEBUG_LOCALCODE}) {
        print " DEBUG: Parsing response for tool calls:\n";
        print "Response length: " . length($response) . " chars\n";
        print "Response contains <tool_call: " . ($response =~ /<tool_call/ ? "YES" : "NO") . "\n";
    }
    
    # Remove code block markers to expose tool calls inside them
    my $extracted_response = $response;
    $extracted_response =~ s/```//g;
    
    # Parse XML-style tool calls with various formats
    # First, try to find complete tool calls (with proper closing >)
    # Use greedy match to get everything between { and the LAST } before >
    # This correctly handles JSON with multiple } like {"key": "value", "key2": "value2"}
    while ($extracted_response =~ /<tool_call\s+name="([^"]+)"\s+args=\{(.+)\}\s*(?:\/?>|>)/gis) {
        my ($tool_name, $args_str) = ($1, $2);
        
        # Skip if not a valid tool
        next unless $tool_name =~ /^(bash|read|write|edit|glob|grep|list|patch|webfetch|websearch|webopen|webfind|webget|todowrite|todoread|task|exec|search)$/i;
        
        # Normalize tool name to lowercase
        $tool_name = lc($tool_name);
        
        # Parse JSON-style arguments
        my %args = $self->_parse_json_args($args_str);
        
        # Convert to array format based on tool type
        my @arg_array = ();
        if ($tool_name eq 'bash' || $tool_name eq 'exec') {
            push @arg_array, $args{command} if $args{command};
        } elsif ($tool_name eq 'read' || $tool_name eq 'list') {
            push @arg_array, $args{filePath} || $args{path} if $args{filePath} || $args{path};
        } elsif ($tool_name eq 'write') {
            push @arg_array, $args{filePath} if $args{filePath};
            push @arg_array, $args{content} if $args{content};
        } elsif ($tool_name eq 'edit') {
            push @arg_array, $args{filePath} if $args{filePath};
            push @arg_array, $args{oldString} if $args{oldString};
            push @arg_array, $args{newString} if $args{newString};
        } elsif ($tool_name eq 'search' || $tool_name eq 'grep') {
            push @arg_array, $args{pattern} if $args{pattern};
            push @arg_array, $args{filePath} || $args{file} if $args{filePath} || $args{file};
        } elsif ($tool_name eq 'glob') {
            push @arg_array, $args{pattern} if $args{pattern};
            push @arg_array, $args{directory} || $args{path} if $args{directory} || $args{path};
        } elsif ($tool_name eq 'patch') {
            push @arg_array, $args{filePath} || $args{file} if $args{filePath} || $args{file};
            push @arg_array, $args{patch} || $args{content} if $args{patch} || $args{content};
        } elsif ($tool_name eq 'webfetch') {
            push @arg_array, $args{url} if $args{url};
        } elsif ($tool_name eq 'websearch') {
            push @arg_array, $args{query} if $args{query};
        } elsif ($tool_name eq 'webopen') {
            push @arg_array, $args{url_or_id} || $args{url} || $args{id} if $args{url_or_id} || $args{url} || $args{id};
        } elsif ($tool_name eq 'webfind') {
            push @arg_array, $args{pattern} if $args{pattern};
        } elsif ($tool_name eq 'webget') {
            push @arg_array, $args{query} if $args{query};
        } elsif ($tool_name eq 'todowrite') {
            push @arg_array, $args{task} || $args{description} if $args{task} || $args{description};
        } elsif ($tool_name eq 'todoread') {
            # No arguments needed for todoread
        } elsif ($tool_name eq 'task') {
            push @arg_array, $args{command} if $args{command};
        }
        
        push @tools, {
            name => $tool_name,
            args => \@arg_array,
            raw_args => \%args,
        };
    }
    
    # Second pass: try to find incomplete tool calls (missing closing >)
    # This handles cases like: <tool_call name="write" args={"filePath": "test", "content": "data"}>some text
    while ($extracted_response =~ /<tool_call\s+name="([^"]+)"\s+args=\{(.*?)\}>\s*/gis) {
        my ($tool_name, $args_str) = ($1, $2);
        
        # Skip if we already found this tool call in the first pass
        next if grep { $_->{name} eq lc($tool_name) } @tools;
        
        # Skip if not a valid tool
        next unless $tool_name =~ /^(bash|read|write|edit|glob|grep|list|patch|webfetch|websearch|webopen|webfind|webget|todowrite|todoread|task|exec|search)$/i;
        
        # Normalize tool name to lowercase
        $tool_name = lc($tool_name);
        
        # Parse JSON-style arguments
        my %args = $self->_parse_json_args($args_str);
        
        # Convert to array format based on tool type
        my @arg_array = ();
        if ($tool_name eq 'bash' || $tool_name eq 'exec') {
            push @arg_array, $args{command} if $args{command};
        } elsif ($tool_name eq 'read' || $tool_name eq 'list') {
            push @arg_array, $args{filePath} || $args{path} if $args{filePath} || $args{path};
        } elsif ($tool_name eq 'write') {
            push @arg_array, $args{filePath} if $args{filePath};
            push @arg_array, $args{content} if $args{content};
        } elsif ($tool_name eq 'edit') {
            push @arg_array, $args{filePath} if $args{filePath};
            push @arg_array, $args{oldString} if $args{oldString};
            push @arg_array, $args{newString} if $args{newString};
        } elsif ($tool_name eq 'search' || $tool_name eq 'grep') {
            push @arg_array, $args{pattern} if $args{pattern};
            push @arg_array, $args{filePath} || $args{file} if $args{filePath} || $args{file};
        } elsif ($tool_name eq 'glob') {
            push @arg_array, $args{pattern} if $args{pattern};
            push @arg_array, $args{directory} || $args{path} if $args{directory} || $args{path};
        } elsif ($tool_name eq 'patch') {
            push @arg_array, $args{filePath} || $args{file} if $args{filePath} || $args{file};
            push @arg_array, $args{patch} || $args{content} if $args{patch} || $args{content};
        } elsif ($tool_name eq 'webfetch') {
            push @arg_array, $args{url} if $args{url};
        } elsif ($tool_name eq 'websearch') {
            push @arg_array, $args{query} if $args{query};
        } elsif ($tool_name eq 'webopen') {
            push @arg_array, $args{url_or_id} || $args{url} || $args{id} if $args{url_or_id} || $args{url} || $args{id};
        } elsif ($tool_name eq 'webfind') {
            push @arg_array, $args{pattern} if $args{pattern};
        } elsif ($tool_name eq 'webget') {
            push @arg_array, $args{query} if $args{query};
        } elsif ($tool_name eq 'todowrite') {
            push @arg_array, $args{task} || $args{description} if $args{task} || $args{description};
        } elsif ($tool_name eq 'todoread') {
            # No arguments needed for todoread
        } elsif ($tool_name eq 'task') {
            push @arg_array, $args{command} if $args{command};
        }
        
        push @tools, {
            name => $tool_name,
            args => \@arg_array,
            raw_args => \%args,
        };
    }
    
    # Second pass: try to find incomplete tool calls (missing closing >)
    while ($extracted_response =~ /<tool_call\s+name="([^"]+)"\s+args=\{([^}]*)\}(?!\s*\/?>)/gis) {
        my ($tool_name, $args_str) = ($1, $2);
        
        # Skip if not a valid tool or already found
        next unless $tool_name =~ /^(bash|read|write|edit|glob|grep|list|patch|webfetch|websearch|webopen|webfind|webget|todowrite|todoread|task|exec|search)$/i;
        
        # Skip if we already have this exact tool call (by comparing raw args strings)
        my %current_args = $self->_parse_json_args($args_str);
        next if grep { $_->{name} eq lc($tool_name) && $_->{raw_args} && $self->_compare_args_hash($_->{raw_args}, \%current_args) } @tools;
        
        # Normalize tool name to lowercase
        $tool_name = lc($tool_name);
        
        # Parse JSON-style arguments
        my %args = $self->_parse_json_args($args_str);
        
        # Convert to array format (reuse same logic)
        my @arg_array = $self->_extract_args_for_tool($tool_name, %args);
        
        # Only add if we have all required arguments for this tool
        next if $self->_missing_required_args($tool_name, \%args);
        
        push @tools, {
            name => $tool_name,
            args => \@arg_array,
            raw_args => \%args,
        };
    }
    
    # Note: Old-style function calls removed - only XML format supported now
    
    return @tools;
}

sub _extract_args_for_tool {
    my ($self, $tool_name, %args) = @_;
    my @arg_array = ();
    
    if ($tool_name eq 'bash' || $tool_name eq 'exec') {
        push @arg_array, $args{command} if $args{command};
    } elsif ($tool_name eq 'read' || $tool_name eq 'list') {
        push @arg_array, $args{filePath} || $args{path} if $args{filePath} || $args{path};
    } elsif ($tool_name eq 'write') {
        push @arg_array, $args{filePath} if $args{filePath};
        push @arg_array, $args{content} if $args{content};
    } elsif ($tool_name eq 'edit') {
        push @arg_array, $args{filePath} if $args{filePath};
        push @arg_array, $args{oldString} if $args{oldString};
        push @arg_array, $args{newString} if $args{newString};
    } elsif ($tool_name eq 'search' || $tool_name eq 'grep') {
        push @arg_array, $args{pattern} if $args{pattern};
        push @arg_array, $args{filePath} || $args{file} if $args{filePath} || $args{file};
    } elsif ($tool_name eq 'glob') {
        push @arg_array, $args{pattern} if $args{pattern};
        push @arg_array, $args{directory} || $args{path} if $args{directory} || $args{path};
    } elsif ($tool_name eq 'patch') {
        push @arg_array, $args{filePath} || $args{file} if $args{filePath} || $args{file};
        push @arg_array, $args{patch} || $args{content} if $args{patch} || $args{content};
    } elsif ($tool_name eq 'webfetch') {
        push @arg_array, $args{url} if $args{url};
    } elsif ($tool_name eq 'websearch') {
        push @arg_array, $args{query} if $args{query};
    } elsif ($tool_name eq 'webopen') {
        push @arg_array, $args{url_or_id} || $args{url} || $args{id} if $args{url_or_id} || $args{url} || $args{id};
    } elsif ($tool_name eq 'webfind') {
        push @arg_array, $args{pattern} if $args{pattern};
    } elsif ($tool_name eq 'webget') {
        push @arg_array, $args{query} if $args{query};
    } elsif ($tool_name eq 'todowrite') {
        push @arg_array, $args{task} || $args{description} if $args{task} || $args{description};
    } elsif ($tool_name eq 'todoread') {
        # No arguments needed for todoread
    } elsif ($tool_name eq 'task') {
        push @arg_array, $args{command} if $args{command};
    }
    
    return @arg_array;
}

sub _compare_args_hash {
    my ($self, $hash1, $hash2) = @_;
    
    # Compare all keys from both hashes
    my %all_keys = map { $_ => 1 } (keys %$hash1, keys %$hash2);
    
    for my $key (keys %all_keys) {
        my $val1 = $hash1->{$key} // '';
        my $val2 = $hash2->{$key} // '';
        return 0 if $val1 ne $val2;
    }
    
    return 1;  # All keys and values match
}

sub _missing_required_args {
    my ($self, $tool_name, $args) = @_;
    
    # Define required arguments for each tool
    my %required_args = (
        'write' => ['filePath', 'content'],
        'edit' => ['filePath', 'oldString', 'newString'],
        'bash' => ['command'],
        'exec' => ['command'],
        'read' => ['filePath'],
        'list' => ['path'],
        'search' => ['pattern', 'filePath'],
        'grep' => ['pattern', 'filePath'],
        'glob' => ['pattern'],
        'patch' => ['filePath', 'patch'],
        'webfetch' => ['url'],
        'websearch' => ['query'],
        'webopen' => ['url_or_id'],
        'webfind' => ['pattern'],
        'webget' => ['query'],
        'todowrite' => ['task'],
        'task' => ['command'],
        # todoread has no required args
    );
    
    my $required = $required_args{$tool_name} || [];
    
    for my $req_arg (@$required) {
        # For some args, check alternative names
        if ($req_arg eq 'filePath') {
            next if $args->{filePath} || $args->{path} || $args->{file};
        } elsif ($req_arg eq 'task') {
            next if $args->{task} || $args->{description};
        } elsif ($req_arg eq 'patch') {
            next if $args->{patch} || $args->{content};
        } elsif ($req_arg eq 'url_or_id') {
            next if $args->{url_or_id} || $args->{url} || $args->{id};
        } else {
            next if $args->{$req_arg};
        }
        
        # Required argument missing
        return 1;
    }
    
    return 0;  # All required arguments present
}

sub format_tool_results {
    my ($self, $tool_results) = @_;
    
    my $feedback = "TOOL EXECUTION RESULTS:\n\n";
    
    for my $result (@$tool_results) {
        $feedback .= "Tool: $result->{tool}\n";
        $feedback .= "Status: " . ($result->{success} ? "SUCCESS" : "FAILED") . "\n";
        $feedback .= "Message: $result->{message}\n";
        
        if ($result->{output}) {
            $feedback .= "Output: $result->{output}\n";
        }
        if ($result->{content}) {
            $feedback .= "Content: $result->{content}\n";
        }
        $feedback .= "---\n";
    }
    
    $feedback .= "\nYou MUST analyze these results and respond appropriately. If there was an error, suggest a fix or try a different approach in your next response.";
    
    return $feedback;
}

sub show_loading {
    my ($self, $message) = @_;
    $message ||= "AI thinking";
    
    # Show loading message
    print "$message";
    STDOUT->flush();
    
    # Return a function to stop loading
    return sub {
        print "\r" . (" " x (length($message) + 10)) . "\r";  # Clear line
        STDOUT->flush();
    };
}

sub show_spinner {
    my ($self, $message) = @_;
    $message ||= "Processing";
    
    my @spinner = ('', '', '', '', '', '', '', '', '', '');
    my $i = 0;
    
    # Return a function to update spinner
    return sub {
        my $action = shift || 'update';
        if ($action eq 'stop') {
            print "\r" . (" " x (length($message) + 10)) . "\r";  # Clear line
            STDOUT->flush();
        } else {
            print "\r$spinner[$i] $message...";
            STDOUT->flush();
            $i = ($i + 1) % @spinner;
        }
    };
}

sub handle_slash_commands {
    my ($self, $command) = @_;
    return 0 unless $command && $command =~ /^\/(.+)/;
    return $self->handle_slash_command($command);
}

sub handle_slash_command {
    my ($self, $command, $client_or_session, $session) = @_;
    
    # Handle different parameter combinations for tests
    my $client = $client_or_session;
    
    # If second parameter is actually a session (has new_session method), adjust
    if ($client_or_session && $client_or_session->can('new_session')) {
        $session = $client_or_session;
        $client = $self->{client};
    }
    
    # Use injected dependencies or instance variables
    $client ||= $self->{client};
    $session ||= $self->{session};
    
    # Initialize config if available
    my $config = $self->{config};
    
    return 0 unless $command =~ /^\/(\w+)(?:\s+(.+))?/;
    my ($cmd, $args) = ($1, $2 || '');
    
    if ($cmd eq 'models') {
        my @models = $client->list_models() if $client;
        my $current = $client->get_current_model() if $client;
        my $output = "Available models:\n";
        for my $model (@models) {
            $output .= "- $model";
            $output .= " (current)" if $current && $model eq $current;
            $output .= "\n";
        }
        return $output;
        
    } elsif ($cmd eq 'current') {
        my $current = $client->get_current_model() if $client;
        return "Current model: " . ($current || 'none');
        
    } elsif ($cmd eq 'model') {
        # If no argument, show current model AND available models
        unless ($args) {
            my $current = $client->get_current_model() if $client;
            my @models = $client->list_models() if $client;

            my $output = "Current model: " . ($current || 'none') . "\n\n";
            $output .= "Available models:\n";
            for my $model (@models) {
                $output .= "- $model";
                $output .= " (current)" if $current && $model eq $current;
                $output .= "\n";
            }
            return $output;
        }
        # Trim whitespace from model name (from autocompletion)
        $args =~ s/^\s+|\s+$//g;
        if ($client && $client->set_model($args)) {
            # Save as last used model
            $self->{config}->save_last_model($args) if $self->{config};
            # Load model info for context tracking
            $client->get_model_info($args);
            return "Switched to model: $args";
        } else {
            return "Model '$args' not found";
        }
        
    } elsif ($cmd eq 'tools') {
        return $self->_show_tools();
        
    } elsif ($cmd eq 'permissions') {
        return $self->_show_permissions();
        
    } elsif ($cmd eq 'config') {
        return $self->_show_config();
        
    } elsif ($cmd eq 'help') {
        return $self->_show_help();
        
    } elsif ($cmd eq 'save') {
        return "Usage: /save <name>" unless $args;
        if ($session && $session->save_session($args)) {
            return "Session saved: $args";
        } else {
            return "Failed to save session: $args";
        }
        
    } elsif ($cmd eq 'load') {
        return "Usage: /load <name>" unless $args;
        if ($session && $session->load_session($args)) {
            return "Session loaded: $args";
        } else {
            return "Failed to load session: $args";
        }
        
    } elsif ($cmd eq 'sessions') {
        if ($session) {
            my @sessions = $session->list_sessions();
            return "Saved sessions:\n" . join("\n", map { "- $_" } @sessions);
        } else {
            return "No session manager available";
        }
        
    } elsif ($cmd eq 'clear') {
        $session->clear_session() if $session;
        return "Session cleared";
        
    } elsif ($cmd eq 'history') {
        if ($args && $args eq 'clear') {
            $session->clear_session() if $session;
            # Also clear command history
            $self->clear_command_history();
            return "History cleared (chat + commands)";
        } else {
            my $limit = $args && $args =~ /^\d+$/ ? int($args) : 20;
            
            # Get both chat history and command history
            my @chat_history = $session ? $session->get_history() : ();
            my @command_history = $self->get_command_history($limit);
            
            # Merge and sort by timestamp
            my @all_history = ();
            
            # Add chat messages
            for my $entry (@chat_history) {
                push @all_history, {
                    timestamp => $entry->{timestamp},
                    type => 'chat',
                    role => $entry->{role},
                    content => $entry->{content}
                };
            }
            
            # Add command history
            for my $entry (@command_history) {
                push @all_history, {
                    timestamp => $entry->{timestamp},
                    type => 'command',
                    content => $entry->{command}
                };
            }
            
            # Sort by timestamp
            @all_history = sort { $a->{timestamp} <=> $b->{timestamp} } @all_history;
            
            # Take last $limit entries
            if (@all_history > $limit) {
                @all_history = @all_history[-$limit..-1];
            }
            
            return "No history available" unless @all_history;
            
            my $output = " Recent History (last " . scalar(@all_history) . " entries):\n\n";
            for my $entry (@all_history) {
                my $timestamp = scalar localtime($entry->{timestamp});
                my $content = substr($entry->{content}, 0, 100);
                $content .= "..." if length($entry->{content}) > 100;
                
                if ($entry->{type} eq 'chat') {
                    $output .= sprintf("[%s] %s: %s\n", 
                        $timestamp, $entry->{role}, $content);
                } else {
                    $output .= sprintf("[%s] command: %s\n", 
                        $timestamp, $content);
                }
            }
            return $output;
        }
        
    } elsif ($cmd eq 'version') {
        my $version = $self->{config} ? $self->{config}->get_version() : '1.2.0';
        return "LocalCode version $version";

    } elsif ($cmd eq 'pwd') {
        # Print working directory
        my $cwd = Cwd::getcwd();
        return "Current directory: $cwd";

    } elsif ($cmd eq 'cd') {
        if ($args) {
            # Expand ~ to home directory
            $args =~ s/^~/$ENV{HOME}/;

            if (chdir($args)) {
                my $cwd = Cwd::getcwd();
                return "Changed directory to: $cwd";
            } else {
                return "Error: Cannot change to directory '$args': $!";
            }
        } else {
            # No argument: show current directory
            my $cwd = Cwd::getcwd();
            return "Current directory: $cwd";
        }

    } elsif ($cmd eq 'exit') {
        $self->save_readline_history();
        return "Goodbye!";

    } else {
        return 0;  # Return false for unknown commands
    }
}

sub _show_tools {
    my ($self) = @_;
    my $output = "Available tools:\n";
    
    # Get actual tools from tools instance
    my @tool_names = ();
    if ($self->{tools}) {
        @tool_names = sort $self->{tools}->list_tools();
    } else {
        # Fallback to default list if tools not available
        @tool_names = qw(read write exec bash search grep edit list glob patch webfetch websearch webopen webfind webget todowrite todoread task);
    }
    
    for my $tool (@tool_names) {
        my $permission_level = 2; # Default to BLOCKED
        if ($self->{tools}) {
            $permission_level = $self->{tools}->check_permission($tool);
        } elsif ($self->{permissions}) {
            $permission_level = $self->{permissions}->get_permission_for_tool($tool);
        }
        
        my $safety = $permission_level == 0 ? '[SAFE]' : 
                     $permission_level == 1 ? '[DANGEROUS]' : 
                     '[BLOCKED]';
        $output .= "- $tool $safety\n";
    }
    
    return $output;
}

sub _show_permissions {
    my ($self) = @_;
    my $output = "Permission settings:\n";
    
    # Categorize tools by permission level
    my (@safe_tools, @dangerous_tools, @blocked_tools);
    
    # Get actual tools from tools instance
    my @tool_names = ();
    if ($self->{tools}) {
        @tool_names = sort $self->{tools}->list_tools();
    } else {
        # Fallback to default list
        @tool_names = qw(read write exec bash search grep edit list glob patch webfetch websearch webopen webfind webget todowrite todoread task);
    }
    
    for my $tool (@tool_names) {
        my $permission_level = 2; # Default to BLOCKED
        if ($self->{tools}) {
            $permission_level = $self->{tools}->check_permission($tool);
        } elsif ($self->{permissions}) {
            $permission_level = $self->{permissions}->get_permission_for_tool($tool);
        }
        
        if ($permission_level == 0) {
            push @safe_tools, $tool;
        } elsif ($permission_level == 1) {
            push @dangerous_tools, $tool;
        } else {
            push @blocked_tools, $tool;
        }
    }
    
    $output .= "Safe tools (auto-allowed): " . join(', ', @safe_tools) . "\n" if @safe_tools;
    $output .= "Dangerous tools (require confirmation): " . join(', ', @dangerous_tools) . "\n" if @dangerous_tools;
    $output .= "Blocked tools (not allowed): " . join(', ', @blocked_tools) . "\n" if @blocked_tools;
    
    return $output;
}

sub _show_config {
    my ($self) = @_;
    # For testing, show default config even without real config object
    my $host = 'localhost';
    my $port = 11434;
    
    if ($self->{config}) {
        $host = $self->{config}->get('ollama.host') || $host;
        $port = $self->{config}->get('ollama.port') || $port;
    }
    
    return "Configuration:\n" .
           "Ollama host: $host:$port\n";
}

sub _show_help {
    my ($self) = @_;
    return "Available commands:\n" .
           "/models               # List available models\n" .
           "/model <name>         # Switch to model\n" .
           "/current              # Show current model\n" .
           "/tools                # List available tools\n" .
           "/permissions          # Show permission settings\n" .
           "/config               # Show current configuration\n" .
           "/save <name>          # Save session\n" .
           "/load <name>          # Load session\n" .
           "/sessions             # List saved sessions\n" .
           "/clear                # Clear current session\n" .
           "/pwd                  # Show current working directory\n" .
           "/cd [path]            # Change or show current directory\n" .
           "/history [N]          # Show last N entries (chat + commands, default 20)\n" .
           "/history clear        # Clear all history (chat + commands)\n" .
           "/version              # Show version information\n" .
           "/help                 # Show this help\n" .
           "/exit                 # Exit LocalCode\n";
}

sub show_permission_dialog {
    my ($self, $tool, $file) = @_;
    
    # In test mode, use auto_approve setting
    if ($self->{test_mode}) {
        return $self->{auto_approve};
    }
    
    # In real mode, this would show interactive dialog
    # For now, default deny
    return 0;
}

sub display_response {
    my ($self, $response) = @_;
    return $response;  # Basic formatting
}

sub show_progress {
    my ($self, $message) = @_;
    return 1;  # Progress shown
}

sub colorize {
    my ($self, $text, $color) = @_;
    return $text;  # No coloring for now
}

sub prompt_user {
    my ($self, $prompt) = @_;
    return $prompt;  # Basic prompting
}

sub handle_input {
    my ($self, $input) = @_;
    return $input;  # Basic input handling
}

# TUI Automation methods for testing

sub read_command_file {
    my ($self, $file) = @_;
    return () unless -f $file;
    
    open my $fh, '<', $file or return ();
    my @commands = ();
    while (my $line = <$fh>) {
        chomp $line;
        push @commands, $line if $line && $line !~ /^\s*#/;
    }
    close $fh;
    
    return @commands;
}

sub parse_stdin_commands {
    my ($self, $input) = @_;
    return split /\n/, $input;
}

sub run_automated_session {
    my ($self, $commands) = @_;
    my $output = "";
    
    for my $command (@$commands) {
        if ($command =~ /^\//) {
            my $result = $self->handle_slash_command($command);
            $output .= $result . "\n" if $result;
        } else {
            # Non-slash commands (tool calls or regular prompts)
            $output .= "Processed: $command\n";
        }
    }
    
    return {
        output => $output,
        completed => 1,
    };
}

sub validate_command_batch {
    my ($self, $commands) = @_;
    my @errors = ();
    
    for my $command (@$commands) {
        if ($command =~ /^\/(\w+)/) {
            my $cmd = $1;
            unless ($cmd =~ /^(models|current|model|tools|permissions|config|help|save|load|sessions|clear|history|version|exit)$/) {
                push @errors, "Unknown command: /$cmd";
            }
        }
    }
    
    return {
        valid => @errors == 0,
        errors => \@errors,
    };
}

sub run_command_with_timeout {
    my ($self, $command) = @_;
    
    # Mock timeout for testing
    if ($command eq '/slowcommand') {
        return {
            success => 0,
            error => "Command timeout"
        };
    }
    
    return {
        success => 1,
        output => "Command executed: $command"
    };
}

sub capture_command_output {
    my ($self, $command) = @_;
    
    my $result = $self->handle_slash_command($command);
    return $result || "Unknown command: $command";
}

sub run_batch_with_error_handling {
    my ($self, $commands) = @_;
    my $success_count = 0;
    my $error_count = 0;
    
    for my $command (@$commands) {
        my $result = $self->handle_slash_command($command);
        if ($result && $result !~ /Unknown command/) {
            $success_count++;
        } else {
            $error_count++;
        }
    }
    
    return {
        completed => 1,
        success_count => $success_count,
        error_count => $error_count,
    };
}

sub set_test_state {
    my ($self, $key, $value) = @_;
    $self->{"test_$key"} = $value;
}

sub run_comprehensive_test_suite {
    my ($self) = @_;
    
    my @test_commands = qw(
        /models /current /tools /permissions /config /help
        /sessions /clear /history /version /exit /model /save
    );
    
    my $validation = $self->validate_command_batch(\@test_commands);
    
    return {
        passed => $validation->{valid},
        total_tests => scalar @test_commands,
    };
}

sub simulate_cli_execution {
    my ($self, $prompt, $args) = @_;
    
    # Simulate CLI execution for testing
    return {
        success => 1,
        output => "Simulated CLI execution: $prompt"
    };
}

sub run_comprehensive_validation {
    my ($self) = @_;
    
    # Validate all systems
    my $failed_checks = 0;
    
    # Check UI commands
    my $ui_result = $self->run_comprehensive_test_suite();
    $failed_checks++ unless $ui_result->{passed};
    
    # Check if all dependencies are available
    $failed_checks++ unless $self->{client};
    $failed_checks++ unless $self->{tools};
    $failed_checks++ unless $self->{permissions};
    $failed_checks++ unless $self->{session};
    
    return {
        all_systems_ok => $failed_checks == 0,
        failed_checks => $failed_checks,
    };
}

sub cleanup_resources {
    my ($self) = @_;
    # Cleanup resources
    return 1;
}

sub get_available_commands {
    my ($self) = @_;
    return qw(
        /models /model /current /tools /permissions /config
        /help /save /load /sessions /clear /pwd /cd /history /version /exit
    );
}

sub autocomplete_command {
    my ($self, $partial) = @_;
    
    # Remove leading slash if present
    $partial =~ s/^\/+//;
    $partial = lc($partial);
    
    my @commands = $self->get_available_commands();
    my @matches = ();
    
    for my $cmd (@commands) {
        my $cmd_name = $cmd;
        $cmd_name =~ s/^\/+//;
        $cmd_name = lc($cmd_name);
        
        if ($cmd_name =~ /^\Q$partial\E/) {
            push @matches, $cmd;
        }
    }
    
    return sort @matches;
}

sub autocomplete_model {
    my ($self, $partial) = @_;
    
    # Get available models from the client
    my @models = ();
    if ($self->{client}) {
        @models = $self->{client}->list_models();
    }
    
    return () unless @models;
    
    # Filter models that match the partial input
    my @matches = ();
    $partial = lc($partial);
    
    for my $model (@models) {
        if (lc($model) =~ /^\Q$partial\E/) {
            push @matches, $model;
        }
    }
    
    return sort @matches;
}

sub setup_readline {
    my ($self) = @_;
    
    # Skip readline setup in test mode to avoid breaking tests
    if ($self->{test_mode}) {
        $self->{has_readline} = 1;
        $self->{completion_available} = 1;
        return;
    }
    
    # Use our own LocalCode::ReadLine implementation (already inlined in build)
    eval {
        # No require needed - LocalCode::ReadLine is already inlined
        my $term = LocalCode::ReadLine->new('LocalCode');
        
        # Setup persistent history file
        my $history_file = File::Spec->catfile($self->{config}->get_localcode_dir(), 'command_history');
        $term->ReadHistory($history_file) if -f $history_file;
        
        # Setup completion function
        my $attribs = $term->Attribs;
        $attribs->{completion_function} = sub {
            my ($text, $line, $start) = @_;
            
            # Check if we're completing a slash command
            if ($text =~ /^\//) {
                return $self->autocomplete_command($text);
            }
            
            # Check if we're completing model names after "/model "
            if ($line =~ /^\/model\s+(.*)$/) {
                my $partial_model = $1;
                return $self->autocomplete_model($partial_model);
            }
            
            return ();
        };
        
        # Enable emacs key bindings explicitly
        $attribs->{keymap} = 'emacs';
        
        # Disable ornaments/decorations to avoid visual artifacts
        $term->ornaments(0);
        
        # Set clean terminal attributes to avoid formatting issues
        if ($attribs) {
            # Completely disable all terminal decorations
            $attribs->{term_set} = ["", "", "", ""];
            $attribs->{standout_open} = "";
            $attribs->{standout_close} = "";
            $attribs->{underline_open} = "";
            $attribs->{underline_close} = "";
            $attribs->{md_mode} = "";
            $attribs->{us_mode} = "";
            $attribs->{so_mode} = "";
            $attribs->{me_mode} = "";
            $attribs->{ue_mode} = "";
            $attribs->{se_mode} = "";
        }
        
        $self->{readline} = $term;
        $self->{has_readline} = 1;
        $self->{completion_available} = 1;
    };
    
    if ($@) {
        # FATAL ERROR - cannot continue without readline
        die "FATAL: LocalCode::ReadLine initialization failed\n\n" .
            "Error: $@\n";
    }
}

sub readline_prompt {
    my ($self, $prompt, $client) = @_;

    if ($self->{has_readline} && $self->{readline}) {
        # Get terminal width and height
        my $term_width = $self->_get_term_width();
        my $term_height = $self->_get_term_height();

        # Store for later use
        $self->{term_width} = $term_width;

        # Disable output buffering
        my $old_fh = select(STDOUT);
        $| = 1;
        select($old_fh);

        # Build the context info
        my $context_info = $self->_build_context_info($client);

        # Build bar with integrated context info on the right
        my $bar = "";
        if ($context_info) {
            # Remove ANSI codes to calculate real length
            my $context_visible = $context_info;
            $context_visible =~ s/\e\[[0-9;]*m//g;

            # Format: [ Context: 18% (770/4096) ]
            my $right_part = "[ Context: " . $context_visible . " ]";
            my $right_len = length($right_part);
            my $left_bars = $term_width - $right_len;
            $left_bars = 3 if $left_bars < 3; # At least a few bars

            $bar = "\e[2m" . ("" x $left_bars) . "\e[0m[ Context: " . $context_info . " ]";
        } else {
            # Just a plain bar if no context info
            $bar = "\e[2m" . ("" x $term_width) . "\e[0m";
        }

        # Print bar BEFORE the prompt
        print $bar . "\n";

        # Explicitly disable ornaments before reading
        my $old_ornaments = $self->{readline}->ornaments(0);

        # Use "> " as the readline prompt
        my $input = $self->{readline}->readline("> ");

        chomp $input if defined $input;

        # Don't restore cursor - let output continue above the bar
        # The bar will scroll up with content naturally

        # Clear any residual formatting after input
        print "\e[0m" if defined $input;

        # Add to history if we have a meaningful command
        if (defined $input && $input ne '' && $self->{readline}->can('add_history')) {
            $self->{readline}->add_history($input);
        }

        return $input;
    } else {
        print $prompt;
        my $input = <STDIN>;
        chomp $input if defined $input;
        return $input;
    }
}

sub _get_term_width {
    my ($self) = @_;

    my $term_width = 80;
    if ($ENV{COLUMNS}) {
        $term_width = $ENV{COLUMNS};
    } elsif (`command -v tput 2>/dev/null`) {
        my $cols = `tput cols 2>/dev/null`;
        chomp $cols;
        $term_width = $cols if $cols =~ /^\d+$/;
    }

    # Store in instance
    $self->{term_width} = $term_width;

    return $term_width;
}

sub get_term_width {
    my ($self) = @_;
    # Always get fresh terminal width
    return $self->_get_term_width();
}

sub _get_term_height {
    my ($self) = @_;

    my $term_height = 24;
    if ($ENV{LINES}) {
        $term_height = $ENV{LINES};
    } elsif (`command -v tput 2>/dev/null`) {
        my $lines = `tput lines 2>/dev/null`;
        chomp $lines;
        $term_height = $lines if $lines =~ /^\d+$/;
    }

    return $term_height;
}

sub _build_context_info {
    my ($self, $client) = @_;

    return "" unless $client;

    my $stats = $client->get_context_stats();
    return "" unless $stats;

    # Don't show if context_window is 0 (model info not loaded yet)
    return "" if $stats->{context_window} == 0;

    my $percentage = $stats->{percentage};
    my $total = $stats->{total_tokens};
    my $window = $stats->{context_window};

    # Color coding based on usage
    my $color_code;
    if ($percentage >= 90) {
        $color_code = "31";  # Red
    } elsif ($percentage >= 70) {
        $color_code = "33";  # Yellow
    } else {
        $color_code = "32";  # Green
    }

    return sprintf("\e[%sm%d%% \e[0m(%d/%d)",
                   $color_code, $percentage, $total, $window);
}

sub _build_prompt_line {
    my ($self, $client, $term_width) = @_;

    my $left_text = "> ";
    my $right_text = "";
    my $right_text_for_readline = "";

    # Context info on the right if available
    if ($client) {
        my $stats = $client->get_context_stats();
        if ($stats && $stats->{context_window} > 0) {
            my $percentage = $stats->{percentage};
            my $total = $stats->{total_tokens};
            my $window = $stats->{context_window};

            # Color coding based on usage
            my $color_code;
            if ($percentage >= 90) {
                $color_code = "31";  # Red
            } elsif ($percentage >= 70) {
                $color_code = "33";  # Yellow
            } else {
                $color_code = "32";  # Green
            }

            # For display (without readline markers)
            $right_text = sprintf("\e[2m\e[%sm%d%% \e[0m\e[2m(%d/%d)\e[0m",
                                  $color_code, $percentage, $total, $window);

            # For readline (with \001 and \002 markers to indicate non-printing chars)
            $right_text_for_readline = sprintf("\001\e[2m\e[%sm\002%d%% \001\e[0m\e[2m\002(%d/%d)\001\e[0m\002",
                                  $color_code, $percentage, $total, $window);
        }
    }

    # Calculate padding (account for ANSI codes don't take visual space)
    my $right_text_visible = $right_text;
    $right_text_visible =~ s/\e\[[0-9;]*m//g;  # Remove ANSI codes for length calculation
    my $padding_needed = $term_width - length($left_text) - length($right_text_visible);
    $padding_needed = 0 if $padding_needed < 0;

    # Build the complete prompt line (use readline version if available)
    my $final_right = $right_text_for_readline || $right_text;
    return $left_text . (" " x $padding_needed) . $final_right;
}

sub save_readline_history {
    my ($self) = @_;
    
    return unless $self->{has_readline} && $self->{readline};
    
    eval {
        my $history_file = File::Spec->catfile($self->{config}->get_localcode_dir(), 'command_history');
        $self->{readline}->WriteHistory($history_file);
    };
    
    warn "Failed to save command history: $@" if $@;
}

sub get_command_history {
    my ($self, $limit) = @_;
    $limit ||= 50;
    
    return () unless $self->{config};
    
    my $history_file = File::Spec->catfile($self->{config}->get_localcode_dir(), 'command_history');
    return () unless -f $history_file;
    
    my @history = ();
    eval {
        open my $fh, '<', $history_file or die "Cannot read command history: $!";
        while (my $line = <$fh>) {
            chomp $line;
            next if $line eq '' || $line =~ /^#/;  # Skip empty lines and comments
            
            # Since readline history doesn't have timestamps, use file mtime as base
            my $mtime = (stat $history_file)[9];
            push @history, {
                command => $line,
                timestamp => $mtime  # This isn't perfect but better than nothing
            };
        }
        close $fh;
    };
    
    warn "Failed to read command history: $@" if $@;
    
    # Take last $limit commands
    if (@history > $limit) {
        @history = @history[-$limit..-1];
    }
    
    return @history;
}

sub clear_command_history {
    my ($self) = @_;
    
    return unless $self->{config};
    
    my $history_file = File::Spec->catfile($self->{config}->get_localcode_dir(), 'command_history');
    
    eval {
        if (-f $history_file) {
            unlink $history_file or die "Cannot delete command history: $!";
        }
        
        # Also clear readline's in-memory history
        if ($self->{has_readline} && $self->{readline}) {
            $self->{readline}->clear_history() if $self->{readline}->can('clear_history');
        }
    };
    
    warn "Failed to clear command history: $@" if $@;
}

1;
# END INLINED MODULE: LocalCode::UI

# BEGIN INLINED MODULE: LocalCode::Session
package LocalCode::Session;
use File::Spec;
use File::Path qw(make_path);

sub new {
    my ($class, %args) = @_;
    
    # Always use ~/.localcode/sessions unless explicitly overridden (for testing)
    my $default_session_dir = File::Spec->catdir($ENV{HOME}, '.localcode', 'sessions');
    
    my $self = {
        session_dir => $args{session_dir} || $default_session_dir,
        config => $args{config},
        current_session => undef,
        history => [],
        max_history => $args{max_history} || 100,
    };
    bless $self, $class;
    
    # Create session directory if it doesn't exist (including parent directories)
    make_path($self->{session_dir}) unless -d $self->{session_dir};
    
    # Initialize messages array for backward compatibility
    $self->{messages} = [];
    
    return $self;
}

sub new_session {
    my ($self, $session_name) = @_;
    
    $self->{current_session} = $session_name;
    $self->{history} = [];
    
    return $session_name;
}


sub get_history {
    my ($self) = @_;
    return @{$self->{history}};
}

sub get_messages_for_chat {
    my ($self, $system_prompt) = @_;
    
    my @messages = ();
    
    # Add system message if provided (this must always be preserved)
    if ($system_prompt) {
        push @messages, {
            role => 'system',
            content => $system_prompt
        };
    }
    
    # Convert history to Ollama chat format
    for my $msg (@{$self->{history}}) {
        # Skip system messages from history (they're for tool feedback)
        next if $msg->{role} eq 'system';
        
        push @messages, {
            role => $msg->{role},
            content => $msg->{content}
        };
    }
    
    return \@messages;
}

sub truncate_history_for_context {
    my ($self, $remove_pairs) = @_;
    
    # Default to removing 3 oldest user/assistant pairs (6 messages)
    $remove_pairs ||= 3;
    my $remove_messages = $remove_pairs * 2;
    
    # Get non-system messages to work with
    my @non_system_history = grep { $_->{role} ne 'system' } @{$self->{history}};
    
    # Only truncate if we have enough messages to remove
    if (@non_system_history > $remove_messages) {
        # Remove the oldest messages (keep everything after the first $remove_messages)
        my @remaining_messages = splice @non_system_history, $remove_messages;
        
        # Rebuild history with system messages preserved and remaining conversation
        my @new_history = ();
        
        # Add back any system messages from the original history
        for my $msg (@{$self->{history}}) {
            if ($msg->{role} eq 'system') {
                push @new_history, $msg;
            }
        }
        
        # Add the remaining non-system messages (oldest removed)
        push @new_history, @remaining_messages;
        
        $self->{history} = \@new_history;
        
        return $remove_messages; # Number of messages removed
    }
    
    return 0; # No messages removed
}

sub compress_history {
    my ($self, $client, $compress_count) = @_;

    # If no compress_count specified, calculate dynamically based on context usage
    if (!$compress_count) {
        my $stats = $client->get_context_stats();
        if ($stats && $stats->{context_window} > 0) {
            my $percentage = $stats->{percentage};
            my $current_tokens = $stats->{total_tokens};
            my $window = $stats->{context_window};

            # Target: get back to 60% usage
            my $target_percentage = 60;
            my $target_tokens = int($window * $target_percentage / 100);
            my $tokens_to_free = $current_tokens - $target_tokens;

            # Estimate ~150 tokens per message pair (user + assistant)
            # This is conservative - actual varies by message length
            my $avg_tokens_per_pair = 150;
            my $pairs_to_compress = int($tokens_to_free / $avg_tokens_per_pair) + 1;

            # Convert pairs to messages (2 messages per pair)
            $compress_count = $pairs_to_compress * 2;

            # Minimum: compress at least 6 messages (3 pairs)
            $compress_count = 6 if $compress_count < 6;

            # Maximum: don't compress more than 80% of history
            my @non_system_history = grep { $_->{role} ne 'system' } @{$self->{history}};
            my $max_compress = int(scalar(@non_system_history) * 0.8);
            $compress_count = $max_compress if $compress_count > $max_compress;
        } else {
            # Fallback if stats not available
            $compress_count = 6;
        }
    }

    # Get non-system messages to work with
    my @non_system_history = grep { $_->{role} ne 'system' } @{$self->{history}};

    # Need at least $compress_count messages to compress
    return 0 if @non_system_history < $compress_count;

    # Extract the oldest messages to compress
    my @to_compress = splice @non_system_history, 0, $compress_count;

    # Build conversation text for summarization
    my $conversation_text = "";
    for my $msg (@to_compress) {
        my $role = ucfirst($msg->{role});
        $conversation_text .= "$role: $msg->{content}\n\n";
    }

    # Ask the AI to summarize
    my $summary_prompt = "Please provide a concise summary of this conversation, preserving key information, decisions, and context:\n\n$conversation_text";

    my $summary = $client->chat($summary_prompt);

    # Check if summarization was successful
    if (!$summary || $summary =~ /^Error:/) {
        # If summarization fails, fall back to truncation
        return 0;
    }

    # Create a system message with the summary
    my $summary_msg = {
        role => 'system',
        content => "Previous conversation summary: $summary"
    };

    # Rebuild history: keep existing system messages, add summary, keep remaining messages
    my @new_history = ();

    # Add back any existing system messages
    for my $msg (@{$self->{history}}) {
        if ($msg->{role} eq 'system') {
            push @new_history, $msg;
        }
    }

    # Add the summary as a system message
    push @new_history, $summary_msg;

    # Add the remaining non-system messages
    push @new_history, @non_system_history;

    $self->{history} = \@new_history;

    return $compress_count; # Number of messages compressed
}

sub save_session {
    my ($self, $session_name) = @_;
    
    $session_name ||= $self->{current_session};
    return 0 unless $session_name;
    
    my $session_file = File::Spec->catfile($self->{session_dir}, "$session_name.json");
    
    my $session_data = {
        name => $session_name,
        history => $self->{history},
        created => time(),
    };
    
    open my $fh, '>', $session_file or return 0;
    print $fh LocalCode::JSON->new->pretty->encode($session_data);
    close $fh;
    
    return 1;
}

sub load_session {
    my ($self, $session_name) = @_;
    
    my $session_file = File::Spec->catfile($self->{session_dir}, "$session_name.json");
    return 0 unless -f $session_file;
    
    open my $fh, '<', $session_file or return 0;
    my $json_text = do { local $/; <$fh> };
    close $fh;
    
    my $session_data = eval { LocalCode::JSON->new->decode($json_text) };
    return 0 unless $session_data;
    
    $self->{current_session} = $session_name;
    $self->{history} = $session_data->{history} || [];
    
    return 1;
}

sub list_sessions {
    my ($self) = @_;
    
    return () unless -d $self->{session_dir};
    
    opendir my $dir, $self->{session_dir} or return ();
    my @files = grep { /\.json$/ } readdir $dir;
    closedir $dir;
    
    # Remove .json extension
    return map { s/\.json$//; $_ } @files;
}

sub clear_session {
    my ($self) = @_;
    $self->{history} = [];
}

sub delete_session {
    my ($self, $session_name) = @_;
    
    my $session_file = File::Spec->catfile($self->{session_dir}, "$session_name.json");
    return 0 unless -f $session_file;
    
    return unlink $session_file;
}

sub cleanup_temp_files {
    my ($self) = @_;
    # For now, this is a no-op, but could clean up temporary session files
    return 1;
}


sub add_message {
    my ($self, $role, $content) = @_;
    
    # Add to session history
    push @{$self->{history}}, {
        role => $role,
        content => $content,
        timestamp => time(),
    };
    
    # Limit session history size
    if (@{$self->{history}} > $self->{max_history}) {
        splice @{$self->{history}}, 0, @{$self->{history}} - $self->{max_history};
    }
    
    # ALSO add to messages array (for backward compatibility with get_messages_for_chat())
    push @{$self->{messages}}, {
        role => $role,
        content => $content,
        timestamp => time()
    };
}

1;
# END INLINED MODULE: LocalCode::Session

# BEGIN INLINED MODULE: LocalCode::Permissions
package LocalCode::Permissions;
# Permission levels

sub new {
    my ($class, %args) = @_;
    my $self = {
        config => $args{config},
        permissions => {
            file_read => 0,      # SAFE
            grep_search => 0,    # SAFE  
            file_write => 1,     # DANGEROUS
            shell_exec => 1,     # DANGEROUS
            file_delete => 1,    # DANGEROUS
            web_fetch => 0,      # SAFE
            web_search => 0,     # SAFE  
            web_open => 0,       # SAFE
        },
        remembered_permissions => {},
        remember_choice => 1,
        testing_mode => 'interactive',
        mock_user_input => '',
        custom_rules => {},
    };
    bless $self, $class;
    return $self;
}

sub SAFE { 0 }
sub DANGEROUS { 1 }
sub BLOCKED { 2 }

sub get_permission {
    my ($self, $tool) = @_;
    return $self->{permissions}->{$tool} // 2; # BLOCKED
}

sub get_permission_for_tool {
    my ($self, $tool_name) = @_;
    
    # Map tool names to permission keys
    my %tool_mapping = (
        'read' => 'file_read',
        'write' => 'file_write', 
        'exec' => 'shell_exec',
        'bash' => 'shell_exec',
        'search' => 'grep_search',
        'grep' => 'grep_search',
        'webfetch' => 'web_fetch',
        'websearch' => 'web_search',
        'webopen' => 'web_open', 
        'webfind' => 'web_search',
        'webget' => 'web_search',
        'edit' => 'file_write',
        'list' => 'file_read',
        'glob' => 'file_read',
        'patch' => 'file_write',
        'todowrite' => 'file_write',
        'todoread' => 'file_read',
        'task' => 'shell_exec',
    );
    
    my $permission_key = $tool_mapping{$tool_name};
    return 2 unless $permission_key; # BLOCKED if unknown tool
    
    return $self->get_permission($permission_key);
}

sub set_permission {
    my ($self, $tool, $level) = @_;
    $self->{permissions}->{$tool} = $level;
}

sub is_safe {
    my ($self, $tool) = @_;
    return $self->get_permission($tool) == 0; # SAFE
}

sub is_dangerous {
    my ($self, $tool) = @_;
    return $self->get_permission($tool) == 1; # DANGEROUS
}

sub is_blocked {
    my ($self, $tool) = @_;
    return $self->get_permission($tool) == 2; # BLOCKED
}

sub set_testing_mode {
    my ($self, $mode) = @_;
    $self->{testing_mode} = $mode;
}

sub request_permission {
    my ($self, $tool, $args) = @_;
    
    # Check if tool is blocked
    return 0 if $self->is_blocked($tool);
    
    # Auto-allow safe tools
    return 1 if $self->is_safe($tool);
    
    # Check custom rules
    if (my $rule = $self->{custom_rules}->{$tool}) {
        return $rule->($tool, $args);
    }
    
    # Handle testing modes
    if ($self->{testing_mode} eq 'auto_yes') {
        return 1;
    } elsif ($self->{testing_mode} eq 'auto_no') {
        return 0;
    }
    
    # Check remembered permissions
    if ($self->{remember_choice}) {
        my $key = "$tool:" . join(',', @$args);
        my $global_key = "${tool}:*";
        return $self->{remembered_permissions}->{$key} if exists $self->{remembered_permissions}->{$key};
        return $self->{remembered_permissions}->{$global_key} if exists $self->{remembered_permissions}->{$global_key};
    }
    
    # Interactive mode - use mock input in testing
    if ($self->{mock_user_input}) {
        my $response = $self->{mock_user_input};
        my $result;
        
        if ($response eq 'y') {
            $result = 1;
        } elsif ($response eq 'n') {
            $result = 0;
        } elsif ($response eq 'a') {
            # Always allow - remember this choice for this tool globally
            $result = 1;
            if ($self->{remember_choice}) {
                $self->{remembered_permissions}->{"${tool}:*"} = 1;
            }
        } else {
            $result = 0;
        }
        
        return $result;
    }
    
    # Default deny for dangerous operations
    return 0;
}

sub reset_remembered_permissions {
    my ($self) = @_;
    $self->{remembered_permissions} = {};
}

sub get_safe_tools {
    my ($self) = @_;
    return grep { $self->is_safe($_) } keys %{$self->{permissions}};
}

sub get_dangerous_tools {
    my ($self) = @_;
    return grep { $self->is_dangerous($_) } keys %{$self->{permissions}};
}

sub validate_tool_request {
    my ($self, $tool, $args) = @_;
    
    # Blocked tools always fail
    return 0 if $self->is_blocked($tool);
    
    # Safe tools always pass
    return 1 if $self->is_safe($tool);
    
    # Check custom rules first
    if (my $rule = $self->{custom_rules}->{$tool}) {
        return $rule->($tool, $args);
    }
    
    # Default validation for dangerous tools
    if ($self->is_dangerous($tool)) {
        # Example: block dangerous rm commands
        if ($tool eq 'shell_exec' && $args->[0] =~ /rm.*-rf/) {
            return 0;
        }
        # For other dangerous tools without custom rules, require permission
        return $self->request_permission($tool, $args);
    }
    
    return 1;
}

sub add_custom_rule {
    my ($self, $tool, $rule_sub) = @_;
    $self->{custom_rules}->{$tool} = $rule_sub;
}

1;
# END INLINED MODULE: LocalCode::Permissions

# BEGIN MAIN SCRIPT
use Getopt::Long;

# Parse command line options
my %opts;
GetOptions(
    \%opts,
    'help|h',
    'version|v',
    'test-all',
    'test-connection',
    'list-models',
    'set-model=s',
    'current-model',
    'auto-yes',
    'auto-no',
    'simulate',
    'test-mode',
    'test-tui-stdin',
    'test-tui-script=s',
    'self-test',
    'config-test',
    'validate-tools',
    'health-check',
);

# Show help
if ($opts{help}) {
    print_help();
    exit 0;
}

# Show version
if ($opts{version}) {
    my $config = LocalCode::Config->new();
    print "LocalCode version " . $config->get_version() . "\n";
    exit 0;
}

# Initialize components
my $config = LocalCode::Config->new();
my $client = LocalCode::Client->new(config => $config);
my $permissions = LocalCode::Permissions->new(config => $config);
my $tools = LocalCode::Tools->new(config => $config, permissions => $permissions);
my $session = LocalCode::Session->new(config => $config);

# Connect to Ollama to detect available models
$client->connect();

# Load last used model
my $last_model = $config->load_last_model();
if ($last_model) {
    # Try to set the model - will only succeed if it's valid
    $client->set_model($last_model);
}

my $ui = LocalCode::UI->new(
    config => $config,
    client => $client,
    tools => $tools,
    permissions => $permissions,
    session => $session,
);

# Set testing modes based on options
if ($opts{'auto-yes'}) {
    $config->set_testing_mode('auto_yes');
    $permissions->set_testing_mode('auto_yes');
    $tools->{auto_approve} = 1;
    $ui->{auto_approve} = 1;
}

if ($opts{'auto-no'}) {
    $config->set_testing_mode('auto_no');
    $permissions->set_testing_mode('auto_no');
    $tools->{auto_approve} = 0;
    $ui->{auto_approve} = 0;
}

if ($opts{simulate}) {
    $config->set_testing_mode('simulate');
    $tools->{simulate_only} = 1;
}

if ($opts{'test-mode'}) {
    $config->set_testing_mode('mock');
    $client->{mock_mode} = 1;
    $client->{mock_models} = ['llama3', 'llama2', 'mistral'];
    $client->set_model('llama3');  # Set default model for test mode
    $tools->{mock_execution} = 1;
    $ui->{test_mode} = 1;
}

# Handle specific commands
if ($opts{'test-connection'}) {
    test_connection($client);
} elsif ($opts{'list-models'}) {
    list_models($client);
} elsif ($opts{'set-model'}) {
    set_model($client, $opts{'set-model'}, $config);
} elsif ($opts{'current-model'}) {
    current_model($client);
} elsif ($opts{'test-all'}) {
    run_all_tests();
} elsif ($opts{'self-test'}) {
    run_self_test($ui, $client, $tools, $permissions);
} elsif ($opts{'config-test'}) {
    test_config($config);
} elsif ($opts{'validate-tools'}) {
    validate_tools($tools);
} elsif ($opts{'health-check'}) {
    health_check($client, $config);
} elsif ($opts{'test-tui-stdin'}) {
    test_tui_stdin($ui);
} elsif ($opts{'test-tui-script'}) {
    test_tui_script($ui, $opts{'test-tui-script'});
} elsif (@ARGV) {
    # Direct prompt mode
    my $prompt = join(' ', @ARGV);
    direct_prompt($ui, $client, $prompt);
} else {
    # Interactive TUI mode
    interactive_mode($ui, $client, $session);
}

# Command implementations
sub print_help {
    print "LocalCode - Perl-based AI Coding Agent for Ollama\n\n";
    print "Usage: localcode [OPTIONS] [PROMPT]\n\n";
    print "Options:\n";
    print "  --help                Show this help\n";
    print "  --version             Show version information\n";
    print "  --list-models         List available Ollama models\n";
    print "  --set-model MODEL     Switch to specific model\n";
    print "  --current-model       Show current model\n";
    print "  --test-connection     Test Ollama connection\n";
    print "  --auto-yes            Auto-approve all permissions\n";
    print "  --auto-no             Auto-deny all permissions\n";
    print "  --simulate            Simulate tool execution\n";
    print "  --test-mode           Mock mode for testing\n";
    print "  --self-test           Run comprehensive self-tests\n";
    print "  --config-test         Test configuration\n";
    print "  --validate-tools      Validate tool definitions\n";
    print "  --health-check        System health check\n";
    print "  --test-tui-stdin      Test TUI with stdin input\n";
    print "  --test-tui-script FILE Test TUI with script file\n\n";
    print "Interactive Commands:\n";
    print "  /help                 Show TUI help\n";
    print "  /models               List models\n";
    print "  /model NAME           Switch model\n";
    print "  /exit                 Exit program\n\n";
    print "Examples:\n";
    print "  localcode                           # Interactive mode\n";
    print "  localcode \"write hello world\"       # Direct prompt\n";
    print "  localcode --auto-yes \"create script\" # Auto-approve mode\n";
    print "  localcode --simulate \"dangerous cmd\" # Simulation mode\n";
}

sub test_connection {
    my ($client) = @_;
    
    if ($client->connect()) {
        print " Connection to Ollama successful\n";
        print "Status: " . $client->get_status() . "\n";
        my @models = $client->list_models();
        print "Available models: " . scalar(@models) . "\n";
        exit 0;
    } else {
        print " Failed to connect to Ollama\n";
        print "Check if Ollama is running on localhost:11434\n";
        exit 1;
    }
}

sub list_models {
    my ($client) = @_;
    
    $client->connect() unless $client->{mock_mode};
    my @models = $client->list_models();
    my $current = $client->get_current_model();
    
    print "Available models:\n";
    for my $model (@models) {
        print "- $model";
        print " (current)" if $current && $model eq $current;
        print "\n";
    }
}

sub set_model {
    my ($client, $model, $config) = @_;
    
    # Trim whitespace from model name
    $model =~ s/^\s+|\s+$//g if $model;
    
    $client->connect() unless $client->{mock_mode};
    if ($client->set_model($model)) {
        print " Switched to model: $model\n";
        
        # Save as last used model
        $config->save_last_model($model) if $config;
    } else {
        print " Model '$model' not found or unavailable\n";
        exit 1;
    }
}

sub current_model {
    my ($client) = @_;
    
    # Connect first to initialize models
    $client->connect() unless $client->{mock_mode};
    
    my $current = $client->get_current_model();
    print "Current model: " . ($current || 'none') . "\n";
}

sub run_all_tests {
    print "Running all tests...\n";
    exec 'make', 'test';
}

sub run_self_test {
    my ($ui, $client, $tools, $permissions) = @_;
    
    print "Running self-tests...\n\n";
    
    # Test UI commands
    print "Testing TUI commands:\n";
    my $result = $ui->run_comprehensive_test_suite();
    print $result->{passed} ? "" : "";
    print " TUI commands: $result->{total_tests} tests\n";
    
    # Test client connection
    print "Testing client:\n";
    $client->{mock_mode} = 1;
    $client->{mock_models} = ['llama3', 'llama2'];
    print $client->connect() ? "" : "";
    print " Client connection\n";
    
    # Test tools
    print "Testing tools:\n";
    my @tool_list = $tools->list_tools();
    print " Tools loaded: " . scalar(@tool_list) . "\n";
    
    print "\nSelf-test completed.\n";
}

sub test_config {
    my ($config) = @_;
    
    print "Testing configuration...\n";
    my $defaults = $config->load_defaults();
    print $config->validate($defaults) ? "" : "";
    print " Configuration validation\n";
    
    print "Ollama host: " . $config->get('ollama.host') . "\n";
    print "Ollama port: " . $config->get('ollama.port') . "\n";
    print "Default model: " . $config->get('ollama.default_model') . "\n";
}

sub validate_tools {
    my ($tools) = @_;
    
    print "Validating tools...\n";
    my @tool_list = $tools->list_tools();
    
    for my $tool (@tool_list) {
        my $valid = $tools->validate_tool($tool);
        my $permission = $tools->check_permission($tool);
        my $safety = $permission == 0 ? 'SAFE' : $permission == 1 ? 'DANGEROUS' : 'BLOCKED';
        
        print $valid ? "" : "";
        print " $tool [$safety]\n";
    }
    
    print "\nTotal tools: " . scalar(@tool_list) . "\n";
}

sub health_check {
    my ($client, $config) = @_;
    
    print "System health check...\n\n";
    
    # Check config
    print "Configuration: ";
    my $defaults = $config->load_defaults();
    print $config->validate($defaults) ? " OK\n" : " FAIL\n";
    
    # Check Ollama connection
    print "Ollama connection: ";
    if ($client->connect()) {
        print " OK\n";
        print "Available models: " . scalar($client->list_models()) . "\n";
    } else {
        print " FAIL\n";
    }
    
    # Check dependencies
    print "Dependencies: ";
    eval { require JSON; require LWP::UserAgent; require YAML::Tiny; };
    print $@ ? " FAIL\n" : " OK\n";
    
    print "\nHealth check completed.\n";
}

sub test_tui_stdin {
    my ($ui) = @_;
    
    # Read commands from stdin
    my $input = do { local $/; <STDIN> };
    my @commands = $ui->parse_stdin_commands($input);
    
    my $result = $ui->run_automated_session(\@commands);
    print $result->{output};
}

sub test_tui_script {
    my ($ui, $script_file) = @_;
    
    my @commands = $ui->read_command_file($script_file);
    unless (@commands) {
        print " Failed to read script file: $script_file\n";
        exit 1;
    }
    
    print "Running TUI script: $script_file\n";
    my $result = $ui->run_automated_session(\@commands);
    print $result->{output};
}

sub direct_prompt {
    my ($ui, $client, $prompt) = @_;
    
    # Connect to Ollama unless in mock mode
    unless ($client->{mock_mode}) {
        unless ($client->connect()) {
            print " Failed to connect to Ollama\n";
            exit 1;
        }
    }
    
    # Create a temporary session for direct prompts
    my $session = LocalCode::Session->new();
    $session->new_session('direct_prompt');
    $session->add_message('user', $prompt);
    
    # Get system prompt and create messages array
    my $system_prompt = $ui->get_system_prompt();
    my $messages = $session->get_messages_for_chat($system_prompt);
    
    # Send to Ollama with full context
    my $response = $client->chat("", undef, $messages);
    
    # Parse tool calls and execute them
    my @tool_calls = $ui->parse_tool_calls($response);
    
    if (@tool_calls) {
        print "Tool calls detected:\n";
        for my $tool_call (@tool_calls) {
            print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
        }
    }
    
    print "\nResponse: $response\n";
}

sub interactive_mode {
    my ($ui, $client, $session) = @_;

    my $version = $config->get_version();

    # ASCII Art Banner with colors
    my $cyan = "\e[36m";
    my $blue = "\e[34m";
    my $bold = "\e[1m";
    my $dim = "\e[2m";
    my $reset = "\e[0m";

    print "\n";
    print "${cyan}${bold}\n";
    print "        \n";
    print "                \n";
    print "     \n";
    print "${reset}${blue}    ${reset}\n";
    print "${dim}    AI Coding Agent  ${reset}${bold}v$version${reset}\n";
    print "${dim}    by Aionda GmbH${reset}\n";
    print "\n";
    print "Type ${bold}/help${reset} for commands or ${bold}/exit${reset} to quit\n";
    
    # Setup readline for autocompletion (REQUIRED - will die if not available)
    $ui->setup_readline();
    
    # Connect to Ollama unless in mock mode
    unless ($client->{mock_mode}) {
        unless ($client->connect()) {
            print " Failed to connect to Ollama\n";
            print "Starting in offline mode...\n\n";
        }
    }
    
    # Ensure a model is selected - but only if no last model was loaded
    my $current_model = $client->get_current_model();
    if (!$current_model && !$client->{mock_mode} && !$last_model) {
        # Try to initialize a model if none is set and no last model was available
        if ($client->initialize_current_model()) {
            $current_model = $client->get_current_model();
        }
    } elsif ($last_model) {
        # Use the loaded last model even if get_current_model() returns undef
        $current_model = $last_model;
    }
    
    # Show current model
    if ($current_model) {
        print "Model: $current_model\n\n";
    } else {
        print "Model: none selected\n\n";
    }
    
    # Create new session
    $session->new_session('interactive_session');

    # Get model info for context window size
    if ($current_model) {
        $client->get_model_info($current_model);
    }

    # Track "always allow" permissions for this session
    my %always_allow_tools = ();

    while (1) {
        my $input = $ui->readline_prompt("", $client);
        chomp $input if defined $input;
        
        # Handle EOF (Ctrl+D) - save history and exit gracefully
        unless (defined $input) {
            print "\n"; # Add newline after Ctrl+D
            $ui->save_readline_history();
            last;
        }
        
        next if $input eq '';
        
        # Handle slash commands
        if ($input =~ /^\//) {
            my $result = $ui->handle_slash_command($input, $client, $session);
            
            if ($result) {
                # Exit on /exit command without printing message again
                if ($input eq '/exit') {
                    print "$result\n";
                    last;
                } else {
                    print "$result\n";
                }
            } else {
                print "Unknown command. Type /help for available commands.\n";
            }
            next;
        }
        
        # Regular chat with full conversation history
        my $system_prompt = $ui->get_system_prompt();

        # Add current user message to session before sending
        $session->add_message('user', $input);

        # Proactive context management: compress history if over 90%
        my $stats = $client->get_context_stats();
        if ($stats && $stats->{percentage} >= 90) {
            print "  Context usage at $stats->{percentage}%, compressing history...\n";
            my $stop_compress = $ui->show_loading(" Summarizing conversation");
            my $compressed = $session->compress_history($client); # Dynamic calculation
            $stop_compress->();

            if ($compressed > 0) {
                print "    Compressed $compressed messages into summary\n";
            } else {
                # Fallback to truncation if compression fails
                print "     Compression failed, falling back to truncation...\n";
                my $removed = $session->truncate_history_for_context(3);
                print "   Removed $removed old messages\n";
            }
        }

        # Try to send chat with full conversation history
        my $response;
        my $retry_count = 0;
        my $max_retries = 3;

        while ($retry_count <= $max_retries) {
            # Get full conversation as messages array
            my $messages = $session->get_messages_for_chat($system_prompt);
            
            # Send to Ollama with full context
            my $stop_loading = $ui->show_loading(" Thinking");
            $response = $client->chat("", undef, $messages);
            $stop_loading->();
            
            # Show response
            print " $response\n\n";
            
            # Check if we got a context length error
            if (ref $response eq 'HASH' && $response->{error} && $response->{error} eq 'context_length_exceeded') {
                $retry_count++;
                if ($retry_count <= $max_retries) {
                    print "  Context length exceeded, truncating history and retrying ($retry_count/$max_retries)...\n";
                    my $removed = $session->truncate_history_for_context(3); # Remove oldest 3 pairs
                    print "   Removed $removed old messages\n";
                } else {
                    print " Context still too long after $max_retries retries. Raw error: $response->{raw_error}\n";
                    $response = "Error: Context length exceeded and could not be resolved by truncating history.";
                    last;
                }
            } else {
                # Success or other error - break out of retry loop
                last;
            }
        }
        
        # Add assistant response to session (only if it's not an error hash)
        if (!ref $response) {
            $session->add_message('assistant', $response);
        }
        
        # Parse and execute tool calls (only if response is a string, not an error hash)
        my @tool_calls = ();
        my $tool_results = [];
        
        if (!ref $response) {
            @tool_calls = $ui->parse_tool_calls($response);
            
            # Debug: Show if response contains tool-related content
            if (!@tool_calls && $response =~ /<tool_call|bash|write|read/i) {
                print " Debug: Response contains tool-related content but no tool calls parsed\n";
                print "   Response preview: " . substr($response, 0, 500) . "...\n";
                print "   Found " . scalar(@tool_calls) . " tool calls\n\n";
            } elsif ($ENV{DEBUG_LOCALCODE}) {
                print " Debug: Found " . scalar(@tool_calls) . " tool calls in response\n";
                for my $call (@tool_calls) {
                    print "   - $call->{name}(" . join(', ', @{$call->{args}}) . ")\n";
                }
                print "\n";
            }
        }
        
        if (@tool_calls) {
            print "\nExecuting tool calls:\n";
            
            # Show how many tool calls we're executing
            if (scalar @tool_calls > 1) {
                print " Executing " . scalar(@tool_calls) . " tool calls in sequence...\n\n";
            }
            
            for my $tool_call (@tool_calls) {
                # Show XML format for clarity
                if ($tool_call->{raw_args}) {
                    my $args_str = join(', ', map { "\"$_\": \"$tool_call->{raw_args}->{$_}\"" } keys %{$tool_call->{raw_args}});
                    print "- <tool_call name=\"$tool_call->{name}\" args={$args_str}>\n";
                } else {
                    print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
                }
                
                # Check permissions and execute
                my $permission = $permissions->get_permission_for_tool($tool_call->{name});
                my $tool_result = {
                    tool => $tool_call->{name},
                    args => $tool_call->{args},
                    success => 0,
                    message => "",
                };
                
                if ($permission == 0) {  # SAFE
                    my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                    if ($result->{success}) {
                        print "   " . ($result->{message} || "Success") . "\n";
                        $tool_result->{success} = 1;
                        $tool_result->{message} = $result->{message} || "Success";
                        
                        # Show output for exec/bash commands and content for read/webfetch/browser tools
                        if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                            my $output = $result->{output};
                            chomp $output;  # Remove trailing newline
                            print "  Output: $output\n";
                            $tool_result->{output} = $output;
                        } elsif (($tool_call->{name} eq 'read' || $tool_call->{name} eq 'webfetch' || $tool_call->{name} eq 'websearch' || $tool_call->{name} eq 'webopen' || $tool_call->{name} eq 'webfind' || $tool_call->{name} eq 'webget') && $result->{content}) {
                            my $content = $result->{content};
                            # Show content length and truncated preview
                            my $content_length = length($content);
                            my $display_content = $content_length > 500 ? substr($content, 0, 500) . "..." : $content;
                            print "  Content ($content_length bytes): $display_content\n";
                            $tool_result->{content} = $content;  # Full content for AI
                        }
                    } else {
                        print "   " . ($result->{error} || $result->{message} || "Failed") . "\n";
                        $tool_result->{success} = 0;
                        $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                        
                        # Show detailed error information
                        if ($result->{output}) {
                            my $output = $result->{output};
                            chomp $output;
                            print "     Error Details: $output\n";
                            $tool_result->{output} = $output;
                        }
                        if ($result->{error} && $result->{error} ne ($result->{message} || "")) {
                            print "     Error Message: $result->{error}\n";
                        }
                        if ($result->{exit_code}) {
                            print "     Exit Code: $result->{exit_code}\n";
                        }
                    }
                } elsif ($permission == 1) {  # DANGEROUS - ask for permission
                    my $auto_approve = $ui->{auto_approve} || 0;
                    my $answer = '';

                    # Check if this tool is in "always allow" list
                    if ($always_allow_tools{$tool_call->{name}}) {
                        print "    This is a dangerous operation (always allowed for this session)!\n";
                        print "  Tool: $tool_call->{name}\n";
                        print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                        $answer = 'y';
                    } elsif ($auto_approve) {
                        print "    This is a dangerous operation (auto-approved)!\n";
                        print "  Tool: $tool_call->{name}\n";
                        print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                        $answer = 'y';
                    } else {
                        print "    This is a dangerous operation!\n";
                        print "  Tool: $tool_call->{name}\n";
                        print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                        print "  Allow? (y/N/a): ";

                        $answer = <STDIN>;
                        chomp $answer if defined $answer;

                        # Handle "always allow" option
                        if ($answer && $answer =~ /^a(lways)?$/i) {
                            $always_allow_tools{$tool_call->{name}} = 1;
                            print "   Tool '$tool_call->{name}' will be always allowed for this session\n";
                            $answer = 'y';  # Treat as 'yes' for this execution
                        }
                    }

                    if ($answer && $answer =~ /^y(es)?$/i) {
                        my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                        if ($result->{success}) {
                            print "   " . ($result->{message} || "Success") . "\n";
                            $tool_result->{success} = 1;
                            $tool_result->{message} = $result->{message} || "Success";
                            
                            # Show output for exec/bash commands and content for read/webfetch/browser tools
                            if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                my $output = $result->{output};
                                chomp $output;  # Remove trailing newline
                                print "  Output: $output\n";
                                $tool_result->{output} = $output;
                            } elsif (($tool_call->{name} eq 'read' || $tool_call->{name} eq 'webfetch' || $tool_call->{name} eq 'websearch' || $tool_call->{name} eq 'webopen' || $tool_call->{name} eq 'webfind' || $tool_call->{name} eq 'webget') && $result->{content}) {
                                my $content = $result->{content};
                                # Show content length and truncated preview
                                my $content_length = length($content);
                                my $display_content = $content_length > 500 ? substr($content, 0, 500) . "..." : $content;
                                print "  Content ($content_length bytes): $display_content\n";
                                $tool_result->{content} = $content;  # Full content for AI
                            }
                        } else {
                            print "   " . ($result->{error} || $result->{message} || "Failed") . "\n";
                            $tool_result->{success} = 0;
                            $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                            
                            # Show detailed error information
                            if ($result->{output}) {
                                my $output = $result->{output};
                                chomp $output;
                                print "     Error Details: $output\n";
                                $tool_result->{output} = $output;
                            }
                            if ($result->{error} && $result->{error} ne ($result->{message} || "")) {
                                print "     Error Message: $result->{error}\n";
                            }
                            if ($result->{exit_code}) {
                                print "     Exit Code: $result->{exit_code}\n";
                            }
                        }
                    } else {
                        print "   Operation cancelled\n";
                        $tool_result->{success} = 0;
                        $tool_result->{message} = "Operation cancelled by user";
                    }
                } else {  # BLOCKED
                    print "   Operation blocked by policy\n";
                    $tool_result->{success} = 0;
                    $tool_result->{message} = "Operation blocked by policy";
                }
                
                push @$tool_results, $tool_result;
            }
            print "\n";
            
            # Send tool results back to LLM for follow-up
            my $tool_feedback = $ui->format_tool_results($tool_results);
            
            # Debug: Show what we're sending to AI
            if ($ENV{DEBUG_LOCALCODE}) {
                print " Debug: Sending to AI:\n$tool_feedback\n\n";
            }
            
            # Add tool results to session first - use 'user' instead of 'system' for better compatibility
            $session->add_message('user', "Tool results:\n" . $tool_feedback);

            # Proactive context management before processing tool results
            my $tool_stats = $client->get_context_stats();
            if ($tool_stats && $tool_stats->{percentage} >= 90) {
                print "  Context usage at $tool_stats->{percentage}%, compressing history...\n";
                my $stop_compress_tool = $ui->show_loading(" Summarizing conversation");
                my $compressed_tool = $session->compress_history($client); # Dynamic calculation
                $stop_compress_tool->();

                if ($compressed_tool > 0) {
                    print "    Compressed $compressed_tool messages into summary\n";
                } else {
                    print "     Compression failed, falling back to truncation...\n";
                    my $removed_tool = $session->truncate_history_for_context(3);
                    print "   Removed $removed_tool old messages\n";
                }
            }

            # Display current context status
            $tool_stats = $client->get_context_stats();
            if ($tool_stats && $tool_stats->{context_window} > 0) {
                my $percentage = $tool_stats->{percentage};
                my $total = $tool_stats->{total_tokens};
                my $window = $tool_stats->{context_window};

                # Color coding
                my $color_code;
                if ($percentage >= 90) {
                    $color_code = "31";  # Red
                } elsif ($percentage >= 70) {
                    $color_code = "33";  # Yellow
                } else {
                    $color_code = "32";  # Green
                }

                my $term_width = $ui->get_term_width();
                my $context_text = sprintf("\e[%sm%d%% \e[0m(%d/%d)", $color_code, $percentage, $total, $window);
                my $context_visible = $context_text;
                $context_visible =~ s/\e\[[0-9;]*m//g;

                my $right_part = "[ Context: " . $context_visible . " ]";
                my $right_len = length($right_part);
                my $left_bars = $term_width - $right_len;
                $left_bars = 3 if $left_bars < 3;

                my $bar = "\e[2m" . ("" x $left_bars) . "\e[0m[ Context: " . $context_text . " ]";
                print $bar . "\n";
            }

            # Get full conversation including tool feedback for follow-up
            my $follow_up_messages = $session->get_messages_for_chat($system_prompt);

            my $stop_loading2 = $ui->show_loading(" Processing tool results");
            my $follow_up_response = $client->chat("", undef, $follow_up_messages);
            $stop_loading2->();

            # Add follow-up response to session and display
            if (!ref $follow_up_response && $follow_up_response && $follow_up_response !~ /^Error:/) {
                $session->add_message('assistant', $follow_up_response);
                print "Follow-up: $follow_up_response\n\n";
                
                # IMPORTANT: Also parse follow-up response for tool calls!
                my @follow_up_tool_calls = $ui->parse_tool_calls($follow_up_response);
                
                if (@follow_up_tool_calls) {
                    print "Follow-up contains " . scalar(@follow_up_tool_calls) . " additional tool calls:\n";
                    
                    my @follow_up_results = ();
                    my $should_stop = 0;
                    
                    for my $tool_call (@follow_up_tool_calls) {
                        print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
                        
                        # Execute the follow-up tool call
                        my $permission = $permissions->get_permission_for_tool($tool_call->{name});
                        my $tool_result = {
                            tool => $tool_call->{name},
                            args => $tool_call->{args},
                            success => 0,
                            message => "",
                        };
                        
                        if ($permission == 0) {  # SAFE
                            my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                            if ($result->{success}) {
                                print "   " . ($result->{message} || "Success") . "\n";
                                $tool_result->{success} = 1;
                                $tool_result->{message} = $result->{message} || "Success";
                                
                                # Show output for relevant tools
                                if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                    my $output = $result->{output};
                                    chomp $output;
                                    print "  Output: $output\n";
                                    $tool_result->{output} = $output;
                                }
                            } else {
                                print "   " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                $tool_result->{success} = 0;
                                $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                                
                                # Show detailed error information
                                if ($result->{output}) {
                                    my $output = $result->{output};
                                    chomp $output;
                                    print "     Error Details: $output\n";
                                    $tool_result->{output} = $output;
                                }
                                $should_stop = 1;  # Stop on first failure
                            }
                        } elsif ($permission == 1) {  # DANGEROUS - ask for permission
                            my $auto_approve = $ui->{auto_approve} || 0;
                            my $answer = '';

                            # Check if this tool is in "always allow" list
                            if ($always_allow_tools{$tool_call->{name}}) {
                                print "    This is a dangerous operation (always allowed for this session)!\n";
                                print "  Tool: $tool_call->{name}\n";
                                print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                $answer = 'y';
                            } elsif ($auto_approve) {
                                print "    This is a dangerous operation (auto-approved)!\n";
                                print "  Tool: $tool_call->{name}\n";
                                print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                $answer = 'y';
                            } else {
                                print "    This is a dangerous operation!\n";
                                print "  Tool: $tool_call->{name}\n";
                                print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                print "  Allow? (y/N/a): ";

                                $answer = <STDIN>;
                                chomp $answer if defined $answer;

                                # Handle "always allow" option
                                if ($answer && $answer =~ /^a(lways)?$/i) {
                                    $always_allow_tools{$tool_call->{name}} = 1;
                                    print "   Tool '$tool_call->{name}' will be always allowed for this session\n";
                                    $answer = 'y';  # Treat as 'yes' for this execution
                                }
                            }

                            if ($answer && $answer =~ /^y(es)?$/i) {
                                my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                                if ($result->{success}) {
                                    print "   " . ($result->{message} || "Success") . "\n";
                                    $tool_result->{success} = 1;
                                    $tool_result->{message} = $result->{message} || "Success";
                                    
                                    # Show output for bash/exec tools
                                    if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                        my $output = $result->{output};
                                        chomp $output;
                                        print "  Output: $output\n";
                                        $tool_result->{output} = $output;
                                    }
                                } else {
                                    print "   " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                    $tool_result->{success} = 0;
                                    $tool_result->{message} = $result->{error} || $result->{message} || "Failed";
                                    
                                    # Show detailed error information
                                    if ($result->{output}) {
                                        my $output = $result->{output};
                                        chomp $output;
                                        print "     Error Details: $output\n";
                                        $tool_result->{output} = $output;
                                    }
                                    $should_stop = 1;  # Stop on first failure
                                }
                            } else {
                                print "   Operation cancelled\n";
                                $tool_result->{success} = 0;
                                $tool_result->{message} = "Operation cancelled by user";
                                $should_stop = 1;  # Stop on cancellation
                            }
                        } else {  # BLOCKED
                            print "   Operation blocked by policy\n";
                            $tool_result->{success} = 0;
                            $tool_result->{message} = "Operation blocked by policy";
                            $should_stop = 1;  # Stop on blocked
                        }
                        
                        push @follow_up_results, $tool_result;
                        
                        # Stop execution on first failure/cancellation/block
                        last if $should_stop;
                    }
                    print "\n";
                    
                    # Send follow-up results back to AI (like regular tool execution)
                    if (@follow_up_results) {
                        my $follow_up_feedback = $ui->format_tool_results(\@follow_up_results);
                        
                        # Debug: Show what we're sending to AI for follow-up results
                        if ($ENV{DEBUG_LOCALCODE}) {
                            print " Debug: Sending follow-up results to AI:\n$follow_up_feedback\n\n";
                        }
                        
                        # Add follow-up tool results to session
                        $session->add_message('user', "Follow-up tool results:\n" . $follow_up_feedback);

                        # Proactive context management before follow-up processing
                        my $followup_stats = $client->get_context_stats();
                        if ($followup_stats && $followup_stats->{percentage} >= 90) {
                            print "  Context usage at $followup_stats->{percentage}%, compressing history...\n";
                            my $stop_compress_followup = $ui->show_loading(" Summarizing conversation");
                            my $compressed_followup = $session->compress_history($client); # Dynamic calculation
                            $stop_compress_followup->();

                            if ($compressed_followup > 0) {
                                print "    Compressed $compressed_followup messages into summary\n";
                            } else {
                                print "     Compression failed, falling back to truncation...\n";
                                my $removed_followup = $session->truncate_history_for_context(3);
                                print "   Removed $removed_followup old messages\n";
                            }
                        }

                        # Display current context status
                        $followup_stats = $client->get_context_stats();
                        if ($followup_stats && $followup_stats->{context_window} > 0) {
                            my $percentage = $followup_stats->{percentage};
                            my $total = $followup_stats->{total_tokens};
                            my $window = $followup_stats->{context_window};

                            # Color coding
                            my $color_code;
                            if ($percentage >= 90) {
                                $color_code = "31";  # Red
                            } elsif ($percentage >= 70) {
                                $color_code = "33";  # Yellow
                            } else {
                                $color_code = "32";  # Green
                            }

                            my $term_width = $ui->get_term_width();
                            my $context_text = sprintf("\e[%sm%d%% \e[0m(%d/%d)", $color_code, $percentage, $total, $window);
                            my $context_visible = $context_text;
                            $context_visible =~ s/\e\[[0-9;]*m//g;

                            my $right_part = "[ Context: " . $context_visible . " ]";
                            my $right_len = length($right_part);
                            my $left_bars = $term_width - $right_len;
                            $left_bars = 3 if $left_bars < 3;

                            my $bar = "\e[2m" . ("" x $left_bars) . "\e[0m[ Context: " . $context_text . " ]";
                            print $bar . "\n";
                        }

                        # Get AI response to follow-up results
                        my $final_messages = $session->get_messages_for_chat($system_prompt);

                        my $stop_loading3 = $ui->show_loading(" Processing follow-up results");
                        my $final_response = $client->chat("", undef, $final_messages);
                        $stop_loading3->();

                        # Display final AI response
                        if (!ref $final_response && $final_response && $final_response !~ /^Error:/) {
                            $session->add_message('assistant', $final_response);
                            print "Final: $final_response\n\n";
                            
                            # IMPORTANT: Also parse final response for tool calls!
                            my @final_tool_calls = $ui->parse_tool_calls($final_response);
                            
                            if (@final_tool_calls) {
                                print "Final response contains " . scalar(@final_tool_calls) . " additional tool calls:\n";
                                
                                for my $tool_call (@final_tool_calls) {
                                    print "- $tool_call->{name}(" . join(', ', @{$tool_call->{args}}) . ")\n";
                                    
                                    # Execute the final tool call
                                    my $permission = $permissions->get_permission_for_tool($tool_call->{name});
                                    my $tool_result = {
                                        tool => $tool_call->{name},
                                        args => $tool_call->{args},
                                        success => 0,
                                        message => "",
                                    };
                                    
                                    if ($permission == 0) {  # SAFE
                                        my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                                        if ($result->{success}) {
                                            print "   " . ($result->{message} || "Success") . "\n";
                                            
                                            # Show output for relevant tools
                                            if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                                my $output = $result->{output};
                                                chomp $output;
                                                print "  Output: $output\n";
                                            } elsif (($tool_call->{name} eq 'read' || $tool_call->{name} eq 'webfetch' || $tool_call->{name} eq 'websearch' || $tool_call->{name} eq 'webopen' || $tool_call->{name} eq 'webfind' || $tool_call->{name} eq 'webget') && $result->{content}) {
                                                my $content = $result->{content};
                                                # Show content length and truncated preview
                                                my $content_length = length($content);
                                                my $display_content = $content_length > 500 ? substr($content, 0, 500) . "..." : $content;
                                                print "  Content ($content_length bytes): $display_content\n";
                                            }
                                        } else {
                                            print "   " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                        }
                                    } elsif ($permission == 1) {  # DANGEROUS - ask for permission
                                        my $auto_approve = $ui->{auto_approve} || 0;
                                        my $answer = '';

                                        # Check if this tool is in "always allow" list
                                        if ($always_allow_tools{$tool_call->{name}}) {
                                            print "    This is a dangerous operation (always allowed for this session)!\n";
                                            print "  Tool: $tool_call->{name}\n";
                                            print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                            $answer = 'y';
                                        } elsif ($auto_approve) {
                                            print "    This is a dangerous operation (auto-approved)!\n";
                                            $answer = 'y';
                                        } else {
                                            print "    This is a dangerous operation!\n";
                                            print "  Tool: $tool_call->{name}\n";
                                            print "  Args: " . join(', ', @{$tool_call->{args}}) . "\n";
                                            print "  Allow? (y/N/a): ";

                                            $answer = <STDIN>;
                                            chomp $answer if defined $answer;

                                            # Handle "always allow" option
                                            if ($answer && $answer =~ /^a(lways)?$/i) {
                                                $always_allow_tools{$tool_call->{name}} = 1;
                                                print "   Tool '$tool_call->{name}' will be always allowed for this session\n";
                                                $answer = 'y';  # Treat as 'yes' for this execution
                                            }
                                        }

                                        if ($answer && $answer =~ /^y(es)?$/i) {
                                            my $result = $tools->execute_tool($tool_call->{name}, $tool_call->{args});
                                            if ($result->{success}) {
                                                print "   " . ($result->{message} || "Success") . "\n";
                                                
                                                # Show output for bash/exec tools
                                                if (($tool_call->{name} eq 'bash' || $tool_call->{name} eq 'exec') && $result->{output}) {
                                                    my $output = $result->{output};
                                                    chomp $output;
                                                    print "  Output: $output\n";
                                                }
                                            } else {
                                                print "   " . ($result->{error} || $result->{message} || "Failed") . "\n";
                                            }
                                        } else {
                                            print "   Operation cancelled\n";
                                        }
                                    } else {  # BLOCKED
                                        print "   Operation blocked by policy\n";
                                    }
                                }
                                print "\n";
                            }
                        } elsif ($final_response =~ /^Error:/) {
                            print "  Final response failed: $final_response\n\n";
                        }
                    }
                }
            } elsif ($follow_up_response =~ /^Error:/) {
                print "  Follow-up failed: $follow_up_response\n";
                print "   Tool execution was successful, but AI follow-up had issues.\n\n";
            } elsif (!$follow_up_response || $follow_up_response eq '') {
                print "  No follow-up response from AI (empty response)\n\n";
            } else {
                print "  Unexpected follow-up response format: " . (ref $follow_up_response || 'string') . "\n\n";
            }
        } else {
            # No tool calls, response already shown above
            # Nothing additional to print
        }
    }
    
    # Only print goodbye if we didn't exit via /exit command
    # (which already printed its own goodbye)
}
# END MAIN SCRIPT
